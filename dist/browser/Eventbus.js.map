{"version":3,"file":"Eventbus.js","sources":["../../src/EventbusSecure.js","../../src/utils.js","../../src/EventbusProxy.js","../../src/Eventbus.js","../../src/index.js"],"sourcesContent":["/**\n * EventbusSecure provides a secure wrapper around another Eventbus instance.\n *\n * The main use case of EventbusSecure is to provide a secure eventbus window for general public consumption. Only\n * events can be triggered, but not registered / unregistered.\n *\n * You must use the initialize method passing in an existing Eventbus instance as the eventbus reference is private.\n * In order to secure the eventbus from unwanted access there is no way to access the eventbus reference externally from\n * the EventbusSecure instance. The initialize method returns an {@link EventbusSecureObj} object which contains two\n * functions to control the secure eventbus externally; `destroy` and `setEventbus`. Expose to end consumers just the\n * `eventbusSecure` instance.\n */\nexport default class EventbusSecure\n{\n   /**\n    * Stores the target eventbus.\n    *\n    * @type {Eventbus}\n    * @private\n    */\n   #eventbus;\n\n   /**\n    * Stores a potentially alternate name instead of returning the wrapped Eventbus instance name.\n    *\n    * @type {string}\n    * @private\n    */\n   #name\n\n   /**\n    * Creates the EventbusSecure instance with an existing instance of Eventbus. An object / EventbusSecureObj is\n    * returned with an EventbusSecure reference and two functions for controlling the underlying Eventbus reference.\n    *\n    * `destroy()` will destroy the underlying Eventbus reference.\n    * `setEventbus(<eventbus>)` will set the underlying reference.\n    *\n    * @param {Eventbus}   eventbus - The target eventbus instance.\n    *\n    * @param {string}     [name] - If a name is provided this will be used instead of eventbus name.\n    *\n    * @returns {EventbusSecureObj} The control object which contains an EventbusSecure reference and control functions.\n    */\n   static initialize(eventbus, name = void 0)\n   {\n      if (name !== void 0 && typeof name !== 'string') { throw new TypeError(`'name' is not a string`); }\n\n      const eventbusSecure = new EventbusSecure();\n      eventbusSecure.#eventbus = eventbus;\n      eventbusSecure.#name = name === void 0 ? eventbus.name : name;\n\n      return {\n         destroy: function()\n         {\n            if (!eventbusSecure.isDestroyed)\n            {\n               eventbusSecure.#eventbus = null;\n\n               if (this) { this.eventbusSecure = void 0 }\n            }\n         },\n\n         setEventbus: function(eventbus, name = void 0)\n         {\n            if (name !== void 0 && typeof name !== 'string') { throw new TypeError(`'name' is not a string`); }\n\n            if (!eventbusSecure.isDestroyed)\n            {\n               // Adopt the new eventbus name as the current name set matches the wrapped eventbus.\n               if (name === void 0 && eventbusSecure.#name === eventbusSecure.#eventbus.name)\n               {\n                  eventbusSecure.#name = eventbus.name;\n               }\n               else if (name !== void 0)\n               {\n                  eventbusSecure.#name = name;\n               }\n\n               eventbusSecure.#eventbus = eventbus;\n            }\n         },\n\n         eventbusSecure\n      };\n   }\n\n   /**\n    * Returns an iterable for the event names / keys of secured eventbus event listeners.\n    *\n    * @param {RegExp} [regex] - Optional regular expression to filter event names.\n    *\n    * @yields\n    */\n   *keys(regex = void 0)\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This EventbusSecure instance has been destroyed.'); }\n\n      for (const entry of this.#eventbus.keys(regex))\n      {\n         yield entry;\n      }\n   }\n\n   /**\n    * Returns whether this instance has already been destroyed.\n    *\n    * @returns {boolean} Is destroyed state.\n    */\n   get isDestroyed()\n   {\n      return this.#eventbus === null;\n   }\n\n   /**\n    * Returns the name associated with this instance.\n    *\n    * @returns {string|*} The target eventbus name.\n    */\n   get name()\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This EventbusSecure instance has been destroyed.'); }\n\n      return this.#name;\n   }\n\n   /**\n    * Trigger callbacks for the given event, or space-delimited list of events. Subsequent arguments to trigger will be\n    * passed along to the event callbacks.\n    *\n    * @param {string}   name - Event name(s)\n    *\n    * @returns {EventbusSecure} This instance.\n    */\n   trigger(name) // eslint-disable-line  no-unused-vars\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This EventbusSecure instance has been destroyed.'); }\n\n      this.#eventbus.trigger(...arguments);\n\n      return this;\n   }\n\n   /**\n    * Provides `trigger` functionality, but collects any returned Promises from invoked targets and returns a\n    * single Promise generated by `Promise.resolve` for a single value or `Promise.all` for multiple results. This is\n    * a very useful mechanism to invoke asynchronous operations over an eventbus.\n    *\n    * @param {string}   name - Event name(s)\n    *\n    * @returns {Promise<void|*|*[]>} A Promise to returning any results.\n    */\n   triggerAsync(name) // eslint-disable-line  no-unused-vars\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This EventbusSecure instance has been destroyed.'); }\n\n      return this.#eventbus.triggerAsync(...arguments);\n   }\n\n   /**\n    * Defers invoking `trigger`. This is useful for triggering events in the next clock tick.\n    *\n    * @param {string}   name - Event name(s)\n    *\n    * @returns {EventbusSecure} This EventbusProxy.\n    */\n   triggerDefer(name) // eslint-disable-line  no-unused-vars\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This EventbusSecure instance has been destroyed.'); }\n\n      this.#eventbus.triggerDefer(...arguments);\n\n      return this;\n   }\n\n   /**\n    * Provides `trigger` functionality, but collects any returned result or results from invoked targets as a single\n    * value or in an array and passes it back to the callee in a synchronous manner.\n    *\n    * @param {string}   name - Event name(s)\n    *\n    * @returns {void|*|*[]} An Array of returned results.\n    */\n   triggerSync(name) // eslint-disable-line  no-unused-vars\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This EventbusSecure instance has been destroyed.'); }\n\n      return this.#eventbus.triggerSync(...arguments);\n   }\n}\n","/**\n * Regular expression used to split event strings.\n *\n * @type {RegExp}\n */\nexport const eventSplitter = /\\s+/;\n\n/**\n * Iterates over the standard `event, callback` (as well as the fancy multiple space-separated events `\"change blur\",\n * callback` and jQuery-style event maps `{event: callback}`).\n *\n * @param {Function}       iteratee - Event operation to invoke.\n *\n * @param {object}         events - Events object\n *\n * @param {string|object}  name - A single event name, compound event names, or a hash of event names.\n *\n * @param {Function}       callback - Event callback function\n *\n * @param {object}         opts - Optional parameters\n *\n * @returns {object|Events} Events object or processed data.\n */\nexport function eventsAPI(iteratee, events, name, callback, opts)\n{\n   let i = 0, names;\n   if (name && typeof name === 'object')\n   {\n      // Handle event maps.\n      if (callback !== void 0 && 'context' in opts && opts.context === void 0) { opts.context = callback; }\n      for (names = objectKeys(name); i < names.length; i++)\n      {\n         events = eventsAPI(iteratee, events, names[i], name[names[i]], opts);\n      }\n   }\n   else if (name && eventSplitter.test(name))\n   {\n      // Handle space-separated event names by delegating them individually.\n      for (names = name.split(eventSplitter); i < names.length; i++)\n      {\n         events = iteratee(events, names[i], callback, opts);\n      }\n   }\n   else\n   {\n      // Finally, standard events.\n      events = iteratee(events, name, callback, opts);\n   }\n   return events;\n}\n\n/**\n * Returns a string to output for error messages including any eventbus name.\n *\n * @param {Eventbus|EventbusProxy|EventbusSecure} eventbus\n *\n * @returns {string}\n */\nexport function getErrorName(eventbus)\n{\n   const name = eventbus.name;\n   return name !== '' ? `[${name}] ` : '';\n}\n\n/**\n * Provides  protected Object.keys functionality.\n *\n * @param {object}   object - Object to retrieve keys.\n *\n * @returns {string[]} Keys of object if any.\n */\nexport const objectKeys = (object) =>\n{\n   return object === null || typeof object !== 'object' ? [] : Object.keys(object);\n};\n\n/**\n * Reduces the event callbacks into a map of `{event: beforeWrapper}`. `after` unbinds the `beforeWrapper` after\n * it has been called the number of times specified by options.count.\n *\n * @param {Events}   map - Events object\n *\n * @param {string}   name - Event name\n *\n * @param {Function} callback - Event callback\n *\n * @param {object}   opts - Function to invoke after event has been triggered once; `off()`\n *\n * @returns {Events} The Events object.\n */\nexport function beforeMap(map, name, callback, opts)\n{\n   const after = opts.after;\n   const count = opts.count + 1;\n\n   if (callback)\n   {\n      const beforeWrapper = map[name] = s_BEFORE(count, function()\n      {\n         return callback.apply(this, arguments);\n      }, () => { after(name, beforeWrapper); });\n\n      beforeWrapper._callback = callback;\n   }\n   return map;\n}\n\n// Module Private ----------------------------------------------------------------------------------------------------\n\n/**\n * Creates a function that invokes `before`, with the `this` binding and arguments of the created function, while\n * it's called less than `count` times. Subsequent calls to the created function return the result of the last `before`\n * invocation.\n *\n * `after` is invoked after the count is reduced.\n *\n * @param {number}   count - The number of calls at which `before` is no longer invoked and then `after` is invoked.\n *\n * @param {Function} before - The function to restrict.\n *\n * @param {Function} after - The function to invoke after count number of calls.\n *\n * @returns {Function} Returns the new restricted function.\n */\nconst s_BEFORE = function(count, before, after)\n{\n   let result;\n\n   return function(...args)\n   {\n      if (--count > 0) { result = before.apply(this, args); }\n\n      if (count <= 1)\n      {\n         if (after) { after.apply(this, args); }\n         after = void 0;\n         before = void 0;\n      }\n\n      return result;\n   };\n};\n","import EventbusSecure from './EventbusSecure.js';\n\nimport * as Utils     from './utils.js';\n\n/**\n * EventbusProxy provides a protected proxy of another Eventbus instance.\n *\n * The main use case of EventbusProxy is to allow indirect access to an eventbus. This is handy when it comes to\n * managing the event lifecycle for a plugin system. When a plugin is added it could receive a callback, perhaps named\n * `onPluginLoaded`, which contains an EventbusProxy instance rather than the direct eventbus. This EventbusProxy\n * instance is associated in the management system controlling plugin lifecycle. When a plugin is removed / unloaded the\n * management system can automatically unregister all events for the plugin without requiring the plugin author doing it\n * correctly if they had full control. IE This allows to plugin system to guarantee no dangling listeners.\n *\n * EventbusProxy provides the on / off, before, once, and trigger methods with the same signatures as found in\n * Eventbus. However, the proxy tracks all added event bindings which is used to proxy between the target\n * eventbus which is passed in from the constructor. All registration methods (on / off / once) proxy. In addition\n * there is a `destroy` method which will unregister all of proxied events and remove references to the managed\n * eventbus. Any further usage of a destroyed EventbusProxy instance results in a ReferenceError thrown.\n *\n * Finally the EventbusProxy only allows events registered through it to be turned off providing a buffer between\n * any consumers such that they can not turn off other registrations made on the eventbus or other proxy instances.\n */\nexport default class EventbusProxy\n{\n   /**\n    * Stores the target eventbus.\n    *\n    * @type {Eventbus}\n    * @private\n    */\n   #eventbus;\n\n   /**\n    * Stores all proxied event bindings.\n    *\n    * @type {Events}\n    * @private\n    */\n   #events;\n\n   /**\n    * Creates the event proxy with an existing instance of Eventbus.\n    *\n    * @param {Eventbus}   eventbus - The target eventbus instance.\n    */\n   constructor(eventbus)\n   {\n      this.#eventbus = eventbus;\n   }\n\n   /**\n    * Just like `on`, but causes the bound callback to fire several times up to the count specified before being\n    * removed. When multiple events are passed in using the space separated syntax, the event\n    * will fire count times for every event you passed in, not once for a combination of all events.\n    *\n    * @param {number}            count - Number of times the function will fire before being removed.\n    *\n    * @param {string|object}     name - Event name(s) or event map.\n    *\n    * @param {Function|object}   callback - Event callback function or context for event map.\n    *\n    * @param {object}            [context] - Event context\n    *\n    * @param {boolean}           [guarded=false] - When set to true this registration is guarded.\n    *\n    * @returns {EventbusProxy} This EventbusProxy instance.\n    */\n   before(count, name, callback, context = void 0, guarded = false)\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This EventbusProxy instance has been destroyed.'); }\n      if (!Number.isInteger(count)) { throw new TypeError(`'count' is not an integer`); }\n\n      const data = {};\n      if (this.#eventbus.isGuarded(name, data))\n      {\n         console.warn(`@typhonjs-plugin/eventbus ${Utils.getErrorName(this)}`\n          + `- before() failed as event name(s) are guarded: ${JSON.stringify(data.names)}`);\n         return this;\n      }\n\n      // Map the event into a `{event: beforeWrapper}` object.\n      const events = Utils.eventsAPI(Utils.beforeMap, {}, name, callback, { count, after: this.off.bind(this) });\n\n      if (typeof name === 'string' && (context === null || context === void 0)) { callback = void 0; }\n\n      return this.on(events, callback, context, guarded);\n   }\n\n   /**\n    * Creates an EventbusSecure instance wrapping the proxied Eventbus reference. An EventbusSecure instance provides a\n    * secure window to public consumers with only trigger dispatch available.\n    *\n    * @param {string}   [name] - Optional name for the EventbusSecure instance.\n    *\n    * @returns {EventbusSecureObj} An EventbusSecure control object for this eventbus.\n    */\n   createSecure(name = void 0)\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This EventbusProxy instance has been destroyed.'); }\n\n      return EventbusSecure.initialize(this.#eventbus, name);\n   }\n\n   /**\n    * Unregisters all proxied events from the target eventbus and removes any local references. All subsequent calls\n    * after `destroy` has been called result in a ReferenceError thrown.\n    */\n   destroy()\n   {\n      if (this.#eventbus !== null)\n      {\n         this.off();\n      }\n\n      this.#events = void 0;\n\n      this.#eventbus = null;\n   }\n\n   /**\n    * Returns an iterable for all events from the proxied eventbus yielding an array with event name, callback function,\n    * and event context.\n    *\n    * @param {RegExp} [regex] - Optional regular expression to filter event names.\n    *\n    * @yields\n    */\n   *entries(regex = void 0)\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This EventbusProxy instance has been destroyed.'); }\n\n      for (const entry of this.#eventbus.entries(regex))\n      {\n         yield entry;\n      }\n   }\n\n   /**\n    * Returns the current proxied eventbus event count.\n    *\n    * @returns {number} Returns the current proxied event count.\n    */\n   get eventCount()\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This EventbusProxy instance has been destroyed.'); }\n\n      return this.#eventbus.eventCount;\n   }\n\n   /**\n    * Returns the current proxied eventbus callback count.\n    *\n    * @returns {number} Returns the current proxied callback count.\n    */\n   get callbackCount()\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This EventbusProxy instance has been destroyed.'); }\n\n      return this.#eventbus.callbackCount;\n   }\n\n   /**\n    * Returns an iterable for the event names / keys of proxied eventbus event listeners.\n    *\n    * @param {RegExp} [regex] - Optional regular expression to filter event names.\n    *\n    * @yields\n    */\n   *keys(regex = void 0)\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This EventbusProxy instance has been destroyed.'); }\n\n      for (const entry of this.#eventbus.keys(regex))\n      {\n         yield entry;\n      }\n   }\n\n   /**\n    * Returns whether this EventbusProxy has already been destroyed.\n    *\n    * @returns {boolean} Is destroyed state.\n    */\n   get isDestroyed()\n   {\n      return this.#eventbus === null;\n   }\n\n   /**\n    * Returns the target eventbus name.\n    *\n    * @returns {string|*} The target eventbus name.\n    */\n   get name()\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This EventbusProxy instance has been destroyed.'); }\n\n      return `proxy-${this.#eventbus.name}`;\n   }\n\n   /**\n    * Returns the current proxied event count.\n    *\n    * @returns {number} Returns the current proxied event count.\n    */\n   get proxyEventCount()\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This EventbusProxy instance has been destroyed.'); }\n\n      if (!this.#events) { return 0; }\n\n      return Object.keys(this.#events).length;\n   }\n\n   /**\n    * Returns the current proxied callback count.\n    *\n    * @returns {number} Returns the current proxied callback count.\n    */\n   get proxyCallbackCount()\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This EventbusProxy instance has been destroyed.'); }\n\n      if (!this.#events) { return 0; }\n\n      let count = 0;\n\n      for (const name in this.#events) { count += this.#events[name].length; }\n\n      return count;\n   }\n\n   /**\n    * Returns whether an event name is guarded.\n    *\n    * @param {string|object}  name - Event name(s) or event map to verify.\n    *\n    * @param {object}         [data] - Stores the output of which names are guarded.\n    *\n    * @returns {boolean} Whether the given event name is guarded.\n    */\n   isGuarded(name, data = {})\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This EventbusProxy instance has been destroyed.'); }\n\n      return this.#eventbus.isGuarded(name, data);\n   }\n\n   /**\n    * Remove a previously-bound proxied event binding.\n    *\n    * Please see {@link Eventbus#off}.\n    *\n    * @param {string|object}  [name] - Event name(s) or event map.\n    *\n    * @param {Function}       [callback] - Event callback function\n    *\n    * @param {object}         [context] - Event context\n    *\n    * @returns {EventbusProxy} This EventbusProxy\n    */\n   off(name = void 0, callback = void 0, context = void 0)\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This EventbusProxy instance has been destroyed.'); }\n\n      this.#events = Utils.eventsAPI(s_OFF_API, this.#events || {}, name, callback, {\n         context: context,\n         eventbus: this.#eventbus\n      });\n\n      return this;\n   }\n\n   /**\n    * Bind a callback function to an object. The callback will be invoked whenever the event is fired. If you have a\n    * large number of different events on a page, the convention is to use colons to namespace them: \"poll:start\", or\n    * \"change:selection\".\n    *\n    * Please see {@link Eventbus#on}.\n    *\n    * @param {string|object}     name - Event name(s) or event map.\n    *\n    * @param {Function|object}   callback - Event callback function or context for event map.\n    *\n    * @param {object}            [context] - Event context\n    *\n    * @param {boolean}           [guarded=false] - When set to true this registration is guarded.\n    *\n    * @returns {EventbusProxy} This EventbusProxy\n    */\n   on(name, callback, context = void 0, guarded = false)\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This EventbusProxy instance has been destroyed.'); }\n\n      const data = {};\n      if (this.#eventbus.isGuarded(name, data))\n      {\n         console.warn(`@typhonjs-plugin/eventbus ${Utils.getErrorName(this)}`\n          + `- on() failed as event name(s) are guarded: ${JSON.stringify(data.names)}`);\n         return this;\n      }\n\n      // Hang onto the options as s_ON_API sets the context we need to pass to the eventbus in `opts.ctx`.\n      const opts = { context, ctx: this, guarded };\n\n      this.#events = Utils.eventsAPI(s_ON_API, this.#events || {}, name, callback, opts);\n\n      this.#eventbus.on(name, callback, opts.ctx, guarded);\n\n      return this;\n   }\n\n   /**\n    * Just like `on`, but causes the bound callback to fire only once before being removed. Handy for saying \"the next\n    * time that X happens, do this\". When multiple events are passed in using the space separated syntax, the event\n    * will fire once for every event you passed in, not once for a combination of all events\n    *\n    * @param {string|object}     name - Event name(s) or event map.\n    *\n    * @param {Function|object}   callback - Event callback function or context for event map.\n    *\n    * @param {object}            context - Event context\n    *\n    * @param {boolean}           [guarded=false] - When set to true this registration is guarded.\n    *\n    * @returns {EventbusProxy} This EventbusProxy instance.\n    */\n   once(name, callback, context = void 0, guarded = false)\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This EventbusProxy instance has been destroyed.'); }\n\n      const data = {};\n      if (this.#eventbus.isGuarded(name, data))\n      {\n         console.warn(`@typhonjs-plugin/eventbus ${Utils.getErrorName(this)}`\n          + `- once() failed as event name(s) are guarded: ${JSON.stringify(data.names)}`);\n         return this;\n      }\n\n      // Map the event into a `{event: beforeWrapper}` object.\n      const events = Utils.eventsAPI(Utils.beforeMap, {}, name, callback, { count: 1, after: this.off.bind(this) });\n\n      if (typeof name === 'string' && (context === null || context === void 0)) { callback = void 0; }\n\n      return this.on(events, callback, context, guarded);\n   }\n\n   /**\n    * Returns an iterable for all stored locally proxied events yielding an array with event name, callback\n    * function, and event context.\n    *\n    * @param {RegExp} [regex] - Optional regular expression to filter event names.\n    *\n    * @yields\n    */\n   *proxyEntries(regex = void 0)\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This EventbusProxy instance has been destroyed.'); }\n      if (regex !== void 0 && !(regex instanceof RegExp)) { throw new TypeError(`'regex' is not a RegExp`); }\n\n      if (!this.#events) { return; }\n\n      if (regex)\n      {\n         for (const name in this.#events)\n         {\n            if (regex.test(name))\n            {\n               for (const event of this.#events[name])\n               {\n                  yield [name, event.callback, event.context, event.guarded];\n               }\n            }\n         }\n      }\n      else\n      {\n         for (const name in this.#events)\n         {\n            for (const event of this.#events[name])\n            {\n               yield [name, event.callback, event.context, event.guarded];\n            }\n         }\n      }\n   }\n\n   /**\n    * Returns an iterable for the event names / keys of the locally proxied event names.\n    *\n    * @param {RegExp} [regex] - Optional regular expression to filter event names.\n    *\n    * @yields\n    */\n   *proxyKeys(regex = void 0)\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This EventbusProxy instance has been destroyed.'); }\n      if (regex !== void 0 && !(regex instanceof RegExp)) { throw new TypeError(`'regex' is not a RegExp`); }\n\n      if (!this.#events) { return; }\n\n      if (regex)\n      {\n         for (const name in this.#events)\n         {\n            if (regex.test(name))\n            {\n               yield name;\n            }\n         }\n      }\n      else\n      {\n         for (const name in this.#events)\n         {\n            yield name;\n         }\n      }\n   }\n\n   /**\n    * Trigger callbacks for the given event, or space-delimited list of events. Subsequent arguments to trigger will be\n    * passed along to the event callbacks.\n    *\n    * @param {string}   name - Event name(s)\n    *\n    * @returns {EventbusProxy} This EventbusProxy.\n    */\n   trigger(name) // eslint-disable-line  no-unused-vars\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This EventbusProxy instance has been destroyed.'); }\n\n      this.#eventbus.trigger(...arguments);\n\n      return this;\n   }\n\n   /**\n    * Provides `trigger` functionality, but collects any returned Promises from invoked targets and returns a\n    * single Promise generated by `Promise.resolve` for a single value or `Promise.all` for multiple results. This is\n    * a very useful mechanism to invoke asynchronous operations over an eventbus.\n    *\n    * @param {string}   name - Event name(s)\n    *\n    * @returns {Promise<void|*|*[]>} A Promise returning any results.\n    */\n   triggerAsync(name) // eslint-disable-line  no-unused-vars\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This EventbusProxy instance has been destroyed.'); }\n\n      return this.#eventbus.triggerAsync(...arguments);\n   }\n\n   /**\n    * Defers invoking `trigger`. This is useful for triggering events in the next clock tick.\n    *\n    * @param {string}   name - Event name(s)\n    *\n    * @returns {EventbusProxy} This EventbusProxy.\n    */\n   triggerDefer(name) // eslint-disable-line  no-unused-vars\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This EventbusProxy instance has been destroyed.'); }\n\n      this.#eventbus.triggerDefer(...arguments);\n\n      return this;\n   }\n\n   /**\n    * Provides `trigger` functionality, but collects any returned result or results from invoked targets as a single\n    * value or in an array and passes it back to the callee in a synchronous manner.\n    *\n    * @param {string}   name - Event name(s)\n    *\n    * @returns {void|*|*[]} An Array of returned results.\n    */\n   triggerSync(name) // eslint-disable-line  no-unused-vars\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This EventbusProxy instance has been destroyed.'); }\n\n      return this.#eventbus.triggerSync(...arguments);\n   }\n}\n\n/**\n * The reducing API that removes a callback from the `events` object. And delegates invoking off to the eventbus\n * reference.\n *\n * @param {Events}   events - Events object\n *\n * @param {string}   name - Event name\n *\n * @param {Function} callback - Event callback\n *\n * @param {object}   opts - Optional parameters\n *\n * @returns {void|Events} Events object\n */\nconst s_OFF_API = (events, name, callback, opts) =>\n{\n   /* c8 ignore next 1 */\n   if (!events) { return; }\n\n   const context = opts.context;\n   const eventbus = opts.eventbus;\n\n   const names = name ? [name] : Utils.objectKeys(events);\n\n   for (let i = 0; i < names.length; i++)\n   {\n      name = names[i];\n      const handlers = events[name];\n\n      // Bail out if there are no events stored.\n      if (!handlers) { break; }\n\n      // Find any remaining events.\n      const remaining = [];\n      for (let j = 0; j < handlers.length; j++)\n      {\n         const handler = handlers[j];\n\n         if (callback && callback !== handler.callback && callback !== handler.callback._callback ||\n          context && context !== handler.context)\n         {\n            remaining.push(handler);\n         }\n      }\n\n      // Replace events if there are any remaining.  Otherwise, clean up.\n      if (remaining.length)\n      {\n         events[name] = remaining;\n      }\n      else\n      {\n         eventbus.off(name, callback, context);\n         delete events[name];\n      }\n   }\n\n   return events;\n};\n\n/**\n * The reducing API that adds a callback to the `events` object.\n *\n * @param {Events}   events - Events object\n *\n * @param {string}   name - Event name\n *\n * @param {Function} callback - Event callback\n *\n * @param {object}   opts - Optional parameters\n *\n * @returns {Events} Events object.\n */\nconst s_ON_API = (events, name, callback, opts) =>\n{\n   if (callback)\n   {\n      const handlers = events[name] || (events[name] = []);\n      const context = opts.context, ctx = opts.ctx;\n      const guarded = typeof opts.guarded === 'boolean' ? opts.guarded /* c8 ignore next */ : false;\n\n      // Set opts `ctx` as this is what we send to the eventbus.\n      opts.ctx = context || ctx;\n\n      handlers.push({ callback, context, ctx: opts.ctx, guarded });\n   }\n\n   return events;\n};\n","import EventbusProxy    from './EventbusProxy.js';\nimport EventbusSecure   from './EventbusSecure.js';\n\nimport * as Utils       from './utils.js';\n\n/**\n * `@typhonjs-plugin/eventbus` / Provides the ability to bind and trigger custom named events.\n *\n * This module is an evolution of Backbone Events. (http://backbonejs.org/#Events). Eventbus extends the\n * functionality provided in Backbone Events with additional triggering methods to receive asynchronous and\n * synchronous results.\n *\n * ---------------\n */\nexport default class Eventbus\n{\n   /**\n    * Stores the name of this eventbus.\n    *\n    * @type {string}\n    * @private\n    */\n   #name = '';\n\n   /**\n    * Stores the events map for associated events and callback / context data.\n    *\n    * @type {Events}\n    * @private\n    */\n   #events;\n\n   /**\n    * Provides a constructor which optionally takes the eventbus name.\n    *\n    * @param {string}   name - Optional eventbus name.\n    */\n   constructor(name = '')\n   {\n      if (typeof name !== 'string') { throw new TypeError(`'name' is not a string`); }\n\n      this.#name = name;\n\n      /**\n       * Stores the Listening instances for this context.\n       *\n       * @type {object.<string, Listening>}\n       * @private\n       */\n      this._listeners = void 0;\n\n      /**\n       * A unique ID set when listened to.\n       *\n       * @type {string}\n       * @private\n       */\n      this._listenId = void 0;\n\n      /**\n       * Stores the Listening instances for other contexts.\n       *\n       * @type {object.<string, Listening>}\n       * @private\n       */\n      this._listeningTo = void 0;\n   }\n\n   /**\n    * Just like `on`, but causes the bound callback to fire several times up to the count specified before being\n    * removed. When multiple events are passed in using the space separated syntax, the event\n    * will fire count times for every event you passed in, not once for a combination of all events.\n    *\n    * @param {number}            count - Number of times the function will fire before being removed.\n    *\n    * @param {string|object}     name - Event name(s) or event map.\n    *\n    * @param {Function|object}   callback - Event callback function or context for event map.\n    *\n    * @param {object}            [context] - Event context\n    *\n    * @param {boolean}           [guarded=false] - When set to true this registration is guarded.\n    *\n    * @returns {Eventbus} This Eventbus instance.\n    */\n   before(count, name, callback, context = void 0, guarded = false)\n   {\n      if (!Number.isInteger(count)) { throw new TypeError(`'count' is not an integer`); }\n\n      const data = {};\n      if (this.isGuarded(name, data))\n      {\n         console.warn(`@typhonjs-plugin/eventbus ${Utils.getErrorName(this)}`\n          + `- before() failed as event name(s) are guarded: ${JSON.stringify(data.names)}`);\n         return this;\n      }\n\n      // Map the event into a `{event: beforeWrapper}` object.\n      const events = Utils.eventsAPI(Utils.beforeMap, {}, name, callback, { count, after: this.off.bind(this) });\n\n      if (typeof name === 'string' && (context === null || context === void 0)) { callback = void 0; }\n\n      return this.on(events, callback, context, guarded);\n   }\n\n   /**\n    * Creates an EventbusProxy wrapping this Eventbus instance. An EventbusProxy proxies events allowing all listeners\n    * added to be easily removed from the wrapped Eventbus.\n    *\n    * @returns {EventbusProxy} A new EventbusProxy for this eventbus.\n    */\n   createProxy()\n   {\n      return new EventbusProxy(this);\n   }\n\n   /**\n    * Creates an EventbusSecure instance wrapping this Eventbus. An EventbusSecure instance provides a secure window to\n    * public consumers with only trigger dispatch available.\n    *\n    * @param {string}   [name] - Optional name for the EventbusSecure instance.\n    *\n    * @returns {EventbusSecureObj} An EventbusSecure control object for this eventbus.\n    */\n   createSecure(name = void 0)\n   {\n      return EventbusSecure.initialize(this, name);\n   }\n\n   /**\n    * Returns an iterable for all stored events yielding an array with event name, callback function, and event context.\n    *\n    * @param {RegExp} [regex] - Optional regular expression to filter event names.\n    *\n    * @yields\n    */\n   *entries(regex = void 0)\n   {\n      if (regex !== void 0 && !(regex instanceof RegExp)) { throw new TypeError(`'regex' is not a RegExp`); }\n\n      if (!this.#events) { return; }\n\n      if (regex)\n      {\n         for (const name in this.#events)\n         {\n            if (regex.test(name))\n            {\n               for (const event of this.#events[name])\n               {\n                  yield [name, event.callback, event.context, event.guarded];\n               }\n            }\n         }\n      }\n      else\n      {\n         for (const name in this.#events)\n         {\n            for (const event of this.#events[name])\n            {\n               yield [name, event.callback, event.context, event.guarded];\n            }\n         }\n      }\n   }\n\n   /**\n    * Returns the current event count.\n    *\n    * @returns {number} Returns the current event count.\n    */\n   get eventCount()\n   {\n      if (!this.#events) { return 0; }\n\n      return Object.keys(this.#events).length;\n   }\n\n   /**\n    * Returns the current callback count.\n    *\n    * @returns {number} The current callback count.\n    */\n   get callbackCount()\n   {\n      if (!this.#events) { return 0; }\n\n      let count = 0;\n\n      for (const name in this.#events) { count += this.#events[name].length; }\n\n      return count;\n   }\n\n   /**\n    * Returns whether an event name is guarded.\n    *\n    * @param {string|object}  name - Event name(s) or event map to verify.\n    *\n    * @param {object}         [data] - Stores the output of which names are guarded.\n    *\n    * @returns {boolean} Whether the given event name is guarded.\n    */\n   isGuarded(name, data = {})\n   {\n      data.names = [];\n      data.guarded = false;\n\n      const result = Utils.eventsAPI(s_IS_GUARDED, data, name, void 0, { events: this.#events });\n\n      return result.guarded;\n   }\n\n   /**\n    * Returns an iterable for the event names / keys of registered event listeners.\n    *\n    * @param {RegExp} [regex] - Optional regular expression to filter event names.\n    *\n    * @yields\n    */\n   *keys(regex = void 0)\n   {\n      if (regex !== void 0 && !(regex instanceof RegExp)) { throw new TypeError(`'regex' is not a RegExp`); }\n\n      if (!this.#events) { return; }\n\n      if (regex)\n      {\n         for (const name in this.#events)\n         {\n            if (regex.test(name))\n            {\n               yield name;\n            }\n         }\n      }\n      else\n      {\n         for (const name in this.#events)\n         {\n            yield name;\n         }\n      }\n   }\n\n   /**\n    * Returns the current eventbus name.\n    *\n    * @returns {string|*} The current eventbus name.\n    */\n   get name()\n   {\n      return this.#name;\n   }\n\n   /**\n    * Tell an object to listen to a particular event on an other object. The advantage of using this form, instead of\n    * other.on(event, callback, object), is that listenTo allows the object to keep track of the events, and they can\n    * be removed all at once later on. The callback will always be called with object as context.\n    *\n    * @example\n    * view.listenTo(model, 'change', view.render);\n    *\n    * @param {object}            obj - Event context\n    *\n    * @param {string|object}     name - Event name(s) or event map.\n    *\n    * @param {Function|object}   callback - Event callback function or context for event map.\n    *\n    * @returns {Eventbus} This Eventbus instance.\n    */\n   listenTo(obj, name, callback)\n   {\n      if (!obj) { return this; }\n\n      const data = {};\n      if (s_TRY_CATCH_IS_GUARDED(obj, name, data))\n      {\n         console.warn(`@typhonjs-plugin/eventbus ${Utils.getErrorName(this)}`\n          + `- listenTo() failed as event name(s) are guarded for target object: ${JSON.stringify(data.names)}`);\n         return this;\n      }\n\n      const id = obj._listenId || (obj._listenId = s_UNIQUE_ID('l'));\n      const listeningTo = this._listeningTo || (this._listeningTo = {});\n      let listening = _listening = listeningTo[id];\n\n      // This object is not listening to any other events on `obj` yet.\n      // Setup the necessary references to track the listening callbacks.\n      if (!listening)\n      {\n         this._listenId || (this._listenId = s_UNIQUE_ID('l'));\n         listening = _listening = listeningTo[id] = new Listening(this, obj);\n      }\n\n      // Bind callbacks on obj.\n      const error = s_TRY_CATCH_ON(obj, name, callback, this);\n      _listening = void 0;\n\n      if (error) { throw error; }\n\n      // If the target obj is not an Eventbus, track events manually.\n      if (listening.interop) { listening.on(name, callback); }\n\n      return this;\n   }\n\n   /**\n    * Just like `listenTo`, but causes the bound callback to fire count times before being removed.\n    *\n    * @param {number}            count - Number of times the function will fire before being removed.\n    *\n    * @param {object}            obj - Target event context.\n    *\n    * @param {string|object}     name - Event name(s) or event map.\n    *\n    * @param {Function|object}   callback - Event callback function or context for event map.\n    *\n    * @returns {Eventbus} This Eventbus instance.\n    */\n   listenToBefore(count, obj, name, callback)\n   {\n      if (!Number.isInteger(count)) { throw new TypeError(`'count' is not an integer`); }\n\n      // Map the event into a `{event: beforeWrapper}` object.\n      const events = Utils.eventsAPI(Utils.beforeMap, {}, name, callback, {\n         count,\n         after: this.stopListening.bind(this, obj)\n      });\n\n      return this.listenTo(obj, events);\n   }\n\n   /**\n    * Just like `listenTo`, but causes the bound callback to fire only once before being removed.\n    *\n    * @param {object}            obj - Target event context\n    *\n    * @param {string|object}     name - Event name(s) or event map.\n    *\n    * @param {Function|object}   callback - Event callback function or context for event map.\n    *\n    * @returns {Eventbus} This Eventbus instance.\n    */\n   listenToOnce(obj, name, callback)\n   {\n      // Map the event into a `{event: beforeWrapper}` object.\n      const events = Utils.eventsAPI(Utils.beforeMap, {}, name, callback, {\n         count: 1,\n         after: this.stopListening.bind(this, obj)\n      });\n\n      return this.listenTo(obj, events);\n   }\n\n   /**\n    * Remove a previously-bound callback function from an object. If no context is specified, all of the versions of\n    * the callback with different contexts will be removed. If no callback is specified, all callbacks for the event\n    * will be removed. If no event is specified, callbacks for all events will be removed.\n    *\n    * Note that calling model.off(), for example, will indeed remove all events on the model — including events that\n    * Backbone uses for internal bookkeeping.\n    *\n    * @example\n    * // Removes just the `onChange` callback.\n    * object.off(\"change\", onChange);\n    *\n    * // Removes all \"change\" callbacks.\n    * object.off(\"change\");\n    *\n    * // Removes the `onChange` callback for all events.\n    * object.off(null, onChange);\n    *\n    * // Removes all callbacks for `context` for all events.\n    * object.off(null, null, context);\n    *\n    * // Removes all callbacks on `object`.\n    * object.off();\n    *\n    * @param {string|object}  [name] - Event name(s) or event map.\n    *\n    * @param {Function}       [callback] - Event callback function\n    *\n    * @param {object}         [context] - Event context\n    *\n    * @returns {Eventbus} This Eventbus instance.\n    */\n   off(name, callback = void 0, context = void 0)\n   {\n      if (!this.#events) { return this; }\n\n      this.#events = Utils.eventsAPI(s_OFF_API, this.#events, name, callback, { context, listeners: this._listeners });\n\n      return this;\n   }\n\n   /**\n    * Bind a callback function to an object. The callback will be invoked whenever the event is fired. If you have a\n    * large number of different events on a page, the convention is to use colons to namespace them: \"poll:start\", or\n    * \"change:selection\".\n    *\n    * To supply a context value for this when the callback is invoked, pass the optional last argument:\n    * model.on('change', this.render, this) or model.on({change: this.render}, this).\n    *\n    * @example\n    * The event string may also be a space-delimited list of several events...\n    * book.on(\"change:title change:author\", ...);\n    *\n    * @example\n    * Callbacks bound to the special \"all\" event will be triggered when any event occurs, and are passed the name of\n    * the event as the first argument. For example, to proxy all events from one object to another:\n    * proxy.on(\"all\", function(eventName) {\n    *    object.trigger(eventName);\n    * });\n    *\n    * @example\n    * All Backbone event methods also support an event map syntax, as an alternative to positional arguments:\n    * book.on({\n    *    \"change:author\": authorPane.update,\n    *    \"change:title change:subtitle\": titleView.update,\n    *    \"destroy\": bookView.remove\n    * });\n    *\n    * @param {string|object}     name - Event name(s) or event map.\n    *\n    * @param {Function|object}   callback - Event callback function or context for event map.\n    *\n    * @param {object}            [context] - Event context\n    *\n    * @param {boolean}           [guarded=false] - When set to true this registration is guarded.\n    *\n    * @returns {Eventbus} This Eventbus instance.\n    */\n   on(name, callback, context = void 0, guarded = false)\n   {\n      const data = {};\n      if (this.isGuarded(name, data))\n      {\n         console.warn(`@typhonjs-plugin/eventbus ${Utils.getErrorName(this)}`\n          + `- on() failed as event name(s) are guarded: ${JSON.stringify(data.names)}`);\n         return this;\n      }\n\n      this.#events = Utils.eventsAPI(s_ON_API, this.#events || {}, name, callback, {\n         context,\n         ctx: this,\n         guarded,\n         listening: _listening\n      });\n\n      if (_listening)\n      {\n         const listeners = this._listeners || (this._listeners = {});\n         listeners[_listening.id] = _listening;\n\n         // Allow the listening to use a counter, instead of tracking callbacks for library interop.\n         _listening.interop = false;\n      }\n\n      return this;\n   }\n\n   /**\n    * Just like `on`, but causes the bound callback to fire only once before being removed. Handy for saying \"the next\n    * time that X happens, do this\". When multiple events are passed in using the space separated syntax, the event\n    * will fire once for every event you passed in, not once for a combination of all events\n    *\n    * @param {string|object}     name - Event name(s) or event map.\n    *\n    * @param {Function|object}   callback - Event callback function or context for event map.\n    *\n    * @param {object}            [context] - Event context\n    *\n    * @param {boolean}           [guarded=false] - When set to true this registration is guarded.\n    *\n    * @returns {Eventbus} This Eventbus instance.\n    */\n   once(name, callback, context = void 0, guarded = false)\n   {\n      const data = {};\n      if (this.isGuarded(name, data))\n      {\n         console.warn(`@typhonjs-plugin/eventbus ${Utils.getErrorName(this)}`\n          + `- once() failed as event name(s) are guarded: ${JSON.stringify(data.names)}`);\n         return this;\n      }\n\n      // Map the event into a `{event: beforeWrapper}` object.\n      const events = Utils.eventsAPI(Utils.beforeMap, {}, name, callback, { count: 1, after: this.off.bind(this) });\n\n      if (typeof name === 'string' && (context === null || context === void 0)) { callback = void 0; }\n\n      return this.on(events, callback, context, guarded);\n   }\n\n   /**\n    * Tell an object to stop listening to events. Either call stopListening with no arguments to have the object remove\n    * all of its registered callbacks ... or be more precise by telling it to remove just the events it's listening to\n    * on a specific object, or a specific event, or just a specific callback.\n    *\n    * @example\n    * view.stopListening();\n    *\n    * view.stopListening(model);\n    *\n    * @param {object}   obj - Event context\n    *\n    * @param {string}   [name] - Event name(s)\n    *\n    * @param {Function} [callback] - Event callback function\n    *\n    * @returns {Eventbus} This Eventbus instance.\n    */\n   stopListening(obj, name = void 0, callback = void 0)\n   {\n      const listeningTo = this._listeningTo;\n      if (!listeningTo) { return this; }\n\n      const ids = obj ? [obj._listenId] : Utils.objectKeys(listeningTo);\n\n      for (let i = 0; i < ids.length; i++)\n      {\n         const listening = listeningTo[ids[i]];\n\n         // If listening doesn't exist, this object is not currently listening to obj. Break out early.\n         if (!listening) { break; }\n\n         listening.obj.off(name, callback, this);\n\n         if (listening.interop) { listening.off(name, callback); }\n      }\n\n      return this;\n   }\n\n   /**\n    * Trigger callbacks for the given event, or space-delimited list of events. Subsequent arguments to trigger will be\n    * passed along to the event callbacks.\n    *\n    * @param {string}   name - Event name(s)\n    *\n    * @returns {Eventbus} This Eventbus instance.\n    */\n   trigger(name)\n   {\n      if (!this.#events) { return this; }\n\n      const length = Math.max(0, arguments.length - 1);\n      const args = new Array(length);\n\n      for (let i = 0; i < length; i++) { args[i] = arguments[i + 1]; }\n\n      s_RESULTS_TARGET_API(s_TRIGGER_API, s_TRIGGER_EVENTS, this.#events, name, void 0, args);\n\n      return this;\n   }\n\n   /**\n    * Provides `trigger` functionality, but collects any returned Promises from invoked targets and returns a\n    * single Promise generated by `Promise.resolve` for a single value or `Promise.all` for multiple results. This is\n    * a very useful mechanism to invoke asynchronous operations over an eventbus.\n    *\n    * @param {string}   name - Event name(s)\n    *\n    * @returns {Promise<void|*|*[]>} A Promise with any results.\n    */\n   async triggerAsync(name)\n   {\n      if (!this.#events) { return void 0; }\n\n      const length = Math.max(0, arguments.length - 1);\n      const args = new Array(length);\n      for (let i = 0; i < length; i++) { args[i] = arguments[i + 1]; }\n\n      const result = s_RESULTS_TARGET_API(s_TRIGGER_API, s_TRIGGER_ASYNC_EVENTS, this.#events, name, void 0, args);\n\n      // No event callbacks were triggered.\n      if (result === void 0) { return void 0; }\n\n      // A single Promise has been returned; just return it.\n      if (!Array.isArray(result)) { return result; }\n\n      // Multiple events & callbacks have been triggered so reduce the returned array of Promises and filter all\n      // values from each Promise result removing any undefined values.\n      return Promise.all(result).then((results) =>\n      {\n         let allResults = [];\n\n         for (const pResult of results)\n         {\n            if (Array.isArray(pResult))\n            {\n               allResults = allResults.concat(pResult);\n            }\n            else if (pResult !== void 0)\n            {\n               allResults.push(pResult);\n            }\n         }\n\n         return allResults.length > 1 ? allResults : allResults.length === 1 ? allResults[0] : void 0;\n      });\n   }\n\n   /**\n    * Defers invoking `trigger`. This is useful for triggering events in the next clock tick.\n    *\n    * @param {string}   name - Event name(s)\n    *\n    * @returns {Eventbus} This Eventbus instance.\n    */\n   triggerDefer(name)   // eslint-disable-line  no-unused-vars\n   {\n      setTimeout(() => { this.trigger(...arguments); }, 0);\n\n      return this;\n   }\n\n   /**\n    * Provides `trigger` functionality, but collects any returned result or results from invoked targets as a single\n    * value or in an array and passes it back to the callee in a synchronous manner.\n    *\n    * @param {string}   name - Event name(s)\n    *\n    * @returns {void|*|*[]} The results of the event invocation.\n    */\n   triggerSync(name)\n   {\n      if (!this.#events) { return void 0; }\n\n      const start = 1;\n      const length = Math.max(0, arguments.length - 1);\n      const args = new Array(length);\n      for (let i = 0; i < length; i++) { args[i] = arguments[i + start]; }\n\n      return s_RESULTS_TARGET_API(s_TRIGGER_API, s_TRIGGER_SYNC_EVENTS, this.#events, name, void 0, args);\n   }\n}\n\n// Private / internal methods ---------------------------------------------------------------------------------------\n\n/**\n * Global listening object\n *\n * @type {Listening}\n */\nlet _listening;\n\n/**\n * A listening class that tracks and cleans up memory bindings when all callbacks have been offed.\n */\nclass Listening\n{\n   /**\n    * @type {Events}\n    */\n   #events;\n\n   /**\n    * @type {string}\n    */\n   #id;\n\n   /**\n    * @type {object}\n    */\n   #listener;\n\n   /**\n    * @type {object}\n    */\n   #obj;\n\n   /**\n    * @type {boolean}\n    */\n   #interop;\n\n   /**\n    * Current listening count.\n    *\n    * @type {number}\n    */\n   #count = 0;\n\n   constructor(listener, obj)\n   {\n      this.#id = listener._listenId;\n      this.#listener = listener;\n      this.#obj = obj;\n      this.#interop = true;\n   }\n\n   // Cleans up memory bindings between the listener and the listenee.\n   cleanup()\n   {\n      delete this.#listener._listeningTo[this.#obj._listenId];\n      if (!this.#interop) { delete this.#obj._listeners[this.#id]; }\n   }\n\n   get id() { return this.#id; }\n\n   get interop() { return this.#interop; }\n\n   get obj() { return this.#obj; }\n\n   incrementCount() { this.#count++; }\n\n   /**\n    * @see {@link Eventbus#on}\n    *\n    * @param {string|object}     name - Event name(s) or event map.\n    *\n    * @param {Function|object}   callback - Event callback function or context for event map.\n    *\n    * @param {object}            [context] - Event context\n    *\n    * @returns {Listening} This Listening instance.\n    */\n   on(name, callback, context = void 0)\n   {\n      this.#events = Utils.eventsAPI(s_ON_API, this.#events || {}, name, callback,\n      {\n         context,\n         ctx: this,\n         listening: this\n      });\n\n      return this;\n   }\n\n   /**\n    * Offs a callback (or several). Uses an optimized counter if the listenee uses Eventbus. Otherwise, falls back to\n    * manual tracking to support events library interop.\n    *\n    * @param {string|object}     [name] - Event name(s) or event map.\n    *\n    * @param {Function|object}   [callback] - Event callback function or context for event map.\n    */\n   off(name, callback)\n   {\n      let cleanup;\n\n      if (this.#interop)\n      {\n         this.#events = Utils.eventsAPI(s_OFF_API, this.#events, name, callback, {\n            context: void 0,\n            listeners: void 0\n         });\n         cleanup = !this.#events;\n      }\n      else\n      {\n         this.#count--;\n         cleanup = this.#count === 0;\n      }\n\n      if (cleanup) { this.cleanup(); }\n   }\n\n   /**\n    * Sets interop.\n    *\n    * @param {boolean} value Value to set.\n    */\n   set interop(value)\n   {\n      /* c8 ignore next 1 */\n      if (typeof value !== 'boolean') { throw new TypeError(`'value' is not a boolean`); }\n      this.#interop = value\n   }\n}\n\n/**\n * The reducing API that tests if an event name is guarded. Any event data of a give event name can have the guarded\n * state set. If so the event name will be added to the output names array and `output.guarded` set to true.\n *\n * @param {object}   output - The output object.\n *\n * @param {string}   name - Event name\n *\n * @param {Function} callback - Event callback\n *\n * @param {object}   opts - Optional parameters\n *\n * @returns {object} The output object.\n */\nconst s_IS_GUARDED = (output, name, callback, opts) =>\n{\n   const events = opts.events;\n\n   if (events)\n   {\n      const handlers = events[name];\n\n      if (Array.isArray(handlers))\n      {\n         for (const handler of handlers)\n         {\n            if (handler.guarded)\n            {\n                output.names.push(name);\n                output.guarded = true;\n                return output;\n            }\n         }\n      }\n   }\n\n   return output;\n}\n\n/**\n * The reducing API that removes a callback from the `events` object.\n *\n * @param {Events}   events - Events object\n *\n * @param {string}   name - Event name\n *\n * @param {Function} callback - Event callback\n *\n * @param {object}   opts - Optional parameters\n *\n * @returns {void|Events} Events object\n */\nconst s_OFF_API = (events, name, callback, opts) =>\n{\n   /* c8 ignore next 1 */\n   if (!events) { return; }\n\n   const context = opts.context, listeners = opts.listeners;\n   let i = 0, names;\n\n   // Delete all event listeners and \"drop\" events.\n   if (!name && !context && !callback)\n   {\n      for (names = Utils.objectKeys(listeners); i < names.length; i++)\n      {\n         listeners[names[i]].cleanup();\n      }\n      return;\n   }\n\n   names = name ? [name] : Utils.objectKeys(events);\n\n   for (; i < names.length; i++)\n   {\n      name = names[i];\n      const handlers = events[name];\n\n      // Bail out if there are no events stored.\n      if (!handlers) { break; }\n\n      // Find any remaining events.\n      const remaining = [];\n      for (let j = 0; j < handlers.length; j++)\n      {\n         const handler = handlers[j];\n         if (callback && callback !== handler.callback && callback !== handler.callback._callback ||\n          context && context !== handler.context)\n         {\n            remaining.push(handler);\n         }\n         else\n         {\n            const listening = handler.listening;\n            if (listening) { listening.off(name, callback); }\n         }\n      }\n\n      // Replace events if there are any remaining.  Otherwise, clean up.\n      if (remaining.length)\n      {\n         events[name] = remaining;\n      }\n      else\n      {\n         delete events[name];\n      }\n   }\n\n   return events;\n};\n\n/**\n * The reducing API that adds a callback to the `events` object.\n *\n * @param {Events}   events - Events object\n *\n * @param {string}   name - Event name\n *\n * @param {Function} callback - Event callback\n *\n * @param {object}   opts - Optional parameters\n *\n * @returns {Events} Events object.\n */\nconst s_ON_API = (events, name, callback, opts) =>\n{\n   if (callback)\n   {\n      const handlers = events[name] || (events[name] = []);\n      const context = opts.context, ctx = opts.ctx, listening = opts.listening;\n      const guarded = typeof opts.guarded === 'boolean' ? opts.guarded : false;\n\n      if (listening) { listening.incrementCount(); }\n\n      handlers.push({ callback, context, ctx: context || ctx, guarded, listening });\n   }\n   return events;\n};\n\n/**\n * Iterates over the standard `event, callback` (as well as the fancy multiple space-separated events `\"change blur\",\n * callback` and jQuery-style event maps `{event: callback}`).\n *\n * @param {Function} iteratee - Trigger API\n *\n * @param {Function} iterateeTarget - Internal function which is dispatched to.\n *\n * @param {Events}   events - Array of stored event callback data.\n *\n * @param {string}   name - Event name\n *\n * @param {Function} callback - callback\n *\n * @param {object}   opts - Optional parameters\n *\n * @returns {*} The results of the callback if any.\n */\nconst s_RESULTS_TARGET_API = (iteratee, iterateeTarget, events, name, callback, opts) =>\n{\n   let results = void 0;\n   let i = 0, names;\n\n   // Handle the case of multiple events being triggered. The potential results of each event & callbacks must be\n   // processed into a single array of results.\n   if (name && Utils.eventSplitter.test(name))\n   {\n      // Handle space-separated event names by delegating them individually.\n      for (names = name.split(Utils.eventSplitter); i < names.length; i++)\n      {\n         const result = iteratee(iterateeTarget, events, names[i], callback, opts);\n\n         // Determine type of `results`; 0: undefined, 1: single value, 2: an array of values.\n         const resultsType = Array.isArray(results) ? 2 : results !== void 0 ? 1 : 0;\n\n         // Handle an array result depending on existing results value.\n         if (Array.isArray(result))\n         {\n            switch (resultsType)\n            {\n               case 0:\n                  // Simply set results.\n                  results = result;\n                  break;\n               case 1:\n                  // Create a new array from existing results then concat the new result array.\n                  results = [results].concat(result);\n                  break;\n               case 2:\n                  // `results` is already an array so concat the new result array.\n                  results = results.concat(result);\n                  break;\n            }\n         }\n         else if (result !== void 0)\n         {\n            switch (resultsType)\n            {\n               case 0:\n                  // Simply set results.\n                  results = result;\n                  break;\n               case 1: {\n                  // Create a new array from existing results then push the new result value.\n                  const newArray = [results];\n                  newArray.push(result);\n                  results = newArray;\n                  break;\n               }\n               case 2:\n                  // `results` is already an array so push the new result array.\n                  results.push(result);\n                  break;\n            }\n         }\n      }\n   }\n   else\n   {\n      // Just single event.\n      results = iteratee(iterateeTarget, events, name, callback, opts);\n   }\n\n   return results;\n};\n\n/**\n * Handles triggering the appropriate event callbacks.\n *\n * @param {Function} iterateeTarget - Internal function which is dispatched to.\n *\n * @param {Events}   objEvents - Array of stored event callback data.\n *\n * @param {string}   name - Event name\n *\n * @param {Function} callback - callback\n *\n * @param {*[]}      args - Arguments supplied to a trigger method.\n *\n * @returns {*} The results from the triggered event.\n */\nconst s_TRIGGER_API = (iterateeTarget, objEvents, name, callback, args) =>\n{\n   let result;\n\n   if (objEvents)\n   {\n      const events = objEvents[name];\n      let allEvents = objEvents.all;\n      if (events && allEvents) { allEvents = allEvents.slice(); }\n      if (events) { result = iterateeTarget(events, args); }\n      if (allEvents) { result = iterateeTarget(allEvents, [name].concat(args)); }\n   }\n\n   return result;\n};\n\n/**\n * A difficult-to-believe, but optimized internal dispatch function for triggering events. Tries to keep the usual\n * cases speedy (most internal Backbone events have 3 arguments).\n *\n * @param {EventData[]} events - Array of stored event callback data.\n *\n * @param {*[]}         args - Event argument array\n */\nconst s_TRIGGER_EVENTS = (events, args) =>\n{\n   let ev, i = -1;\n   const a1 = args[0], a2 = args[1], a3 = args[2], l = events.length;\n\n   switch (args.length)\n   {\n      case 0:\n         while (++i < l) { (ev = events[i]).callback.call(ev.ctx); }\n         return;\n      case 1:\n         while (++i < l) { (ev = events[i]).callback.call(ev.ctx, a1); }\n         return;\n      case 2:\n         while (++i < l) { (ev = events[i]).callback.call(ev.ctx, a1, a2); }\n         return;\n      case 3:\n         while (++i < l) { (ev = events[i]).callback.call(ev.ctx, a1, a2, a3); }\n         return;\n      default:\n         while (++i < l) { (ev = events[i]).callback.apply(ev.ctx, args); }\n         return;\n   }\n};\n\n/**\n * A difficult-to-believe, but optimized internal dispatch function for triggering events. Tries to keep the usual\n * cases speedy (most internal Backbone events have 3 arguments). This dispatch method uses ES6 Promises and adds\n * any returned results to an array which is added to a Promise.all construction which passes back a Promise which\n * waits until all Promises complete. Any target invoked may return a Promise or any result. This is very useful to\n * use for any asynchronous operations.\n *\n * @param {EventData[]} events - Array of stored event callback data.\n *\n * @param {*[]}         args - Arguments supplied to `triggerAsync`.\n *\n * @returns {Promise<void|*|*[]>} A Promise of the results from the triggered event.\n */\nconst s_TRIGGER_ASYNC_EVENTS = async (events, args) =>\n{\n   let ev, i = -1;\n   const a1 = args[0], a2 = args[1], a3 = args[2], l = events.length;\n\n   const results = [];\n\n   switch (args.length)\n   {\n      case 0:\n         while (++i < l)\n         {\n            const result = (ev = events[i]).callback.call(ev.ctx);\n\n            // If we received a valid result add it to the promises array.\n            if (result !== void 0) { results.push(result); }\n         }\n         break;\n\n      case 1:\n         while (++i < l)\n         {\n            const result = (ev = events[i]).callback.call(ev.ctx, a1);\n\n            // If we received a valid result add it to the promises array.\n            if (result !== void 0) { results.push(result); }\n         }\n         break;\n\n      case 2:\n         while (++i < l)\n         {\n            const result = (ev = events[i]).callback.call(ev.ctx, a1, a2);\n\n            // If we received a valid result add it to the promises array.\n            if (result !== void 0) { results.push(result); }\n         }\n         break;\n\n      case 3:\n         while (++i < l)\n         {\n            const result = (ev = events[i]).callback.call(ev.ctx, a1, a2, a3);\n\n            // If we received a valid result add it to the promises array.\n            if (result !== void 0) { results.push(result); }\n         }\n         break;\n\n      default:\n         while (++i < l)\n         {\n            const result = (ev = events[i]).callback.apply(ev.ctx, args);\n\n            // If we received a valid result add it to the promises array.\n            if (result !== void 0) { results.push(result); }\n         }\n         break;\n   }\n\n   // If there are multiple results then use Promise.all otherwise Promise.resolve. Filter out any undefined results.\n   return results.length > 1 ? Promise.all(results).then((values) =>\n   {\n      const filtered = values.filter((entry) => entry !== void 0);\n      switch (filtered.length)\n      {\n         case 0: return void 0;\n         case 1: return filtered[0];\n         default: return filtered;\n      }\n   }) : results.length === 1 ? results[0] : void 0;\n};\n\n/**\n * A difficult-to-believe, but optimized internal dispatch function for triggering events. Tries to keep the usual\n * cases speedy (most internal Backbone events have 3 arguments). This dispatch method synchronously passes back a\n * single value or an array with all results returned by any invoked targets.\n *\n * @param {EventData[]} events - Array of stored event callback data.\n *\n * @param {*[]}         args - Arguments supplied to `triggerSync`.\n *\n * @returns {void|*|*[]} The results from the triggered event.\n */\nconst s_TRIGGER_SYNC_EVENTS = (events, args) =>\n{\n   let ev, i = -1;\n   const a1 = args[0], a2 = args[1], a3 = args[2], l = events.length;\n\n   const results = [];\n\n   switch (args.length)\n   {\n      case 0:\n         while (++i < l)\n         {\n            const result = (ev = events[i]).callback.call(ev.ctx);\n\n            // If we received a valid result return immediately.\n            if (result !== void 0) { results.push(result); }\n         }\n         break;\n      case 1:\n         while (++i < l)\n         {\n            const result = (ev = events[i]).callback.call(ev.ctx, a1);\n\n            // If we received a valid result return immediately.\n            if (result !== void 0) { results.push(result); }\n         }\n         break;\n      case 2:\n         while (++i < l)\n         {\n            const result = (ev = events[i]).callback.call(ev.ctx, a1, a2);\n\n            // If we received a valid result return immediately.\n            if (result !== void 0) { results.push(result); }\n         }\n         break;\n      case 3:\n         while (++i < l)\n         {\n            const result = (ev = events[i]).callback.call(ev.ctx, a1, a2, a3);\n\n            // If we received a valid result return immediately.\n            if (result !== void 0) { results.push(result); }\n         }\n         break;\n      default:\n         while (++i < l)\n         {\n            const result = (ev = events[i]).callback.apply(ev.ctx, args);\n\n            // If we received a valid result return immediately.\n            if (result !== void 0) { results.push(result); }\n         }\n         break;\n   }\n\n   // Return the results array if there are more than one or just a single result.\n   return results.length > 1 ? results : results.length === 1 ? results[0] : void 0;\n};\n\n/**\n * A try-catch guarded function. Used when attempting to invoke `isGuarded` from an other eventbus / context via\n * `listenTo`.\n *\n * @param {object}         obj - Event target / context\n *\n * @param {string|object}  name - Event name(s) or event map.\n *\n * @param {object}         data - Output data.\n *\n * @returns {boolean} Any error if thrown.\n */\nconst s_TRY_CATCH_IS_GUARDED = (obj, name, data = {}) =>\n{\n   let guarded = false;\n\n   try\n   {\n      const result = obj.isGuarded(name, data);\n      if (typeof result === 'boolean') { guarded = result; }\n   }\n   catch (err)\n   {\n      guarded = false;\n      data.names = [];\n      data.guarded = false;\n   }\n\n   return guarded;\n};\n\n/**\n * A try-catch guarded #on function, to prevent poisoning the global `_listening` variable. Used when attempting to\n * invoke `on` from an other eventbus / context via `listenTo`.\n *\n * @param {object}            obj - Event target / context\n *\n * @param {string|object}     name - Event name(s) or event map.\n *\n * @param {Function|object}   callback - Event callback function or context for event map.\n *\n * @param {object}            [context] - Event context\n *\n * @returns {Error} Any error if thrown.\n */\nconst s_TRY_CATCH_ON = (obj, name, callback, context) =>\n{\n   try\n   {\n      obj.on(name, callback, context);\n   }\n   catch (err)\n   {\n      return err;\n   }\n};\n\n/**\n * Generate a unique integer ID (unique within the entire client session).\n *\n * @type {number} - unique ID counter.\n */\nlet idCounter = 0;\n\n/**\n * Creates a new unique ID with a given prefix\n *\n * @param {string}   prefix - An optional prefix to add to unique ID.\n *\n * @returns {string} A new unique ID with a given prefix.\n */\nconst s_UNIQUE_ID = (prefix = '') =>\n{\n   const id = `${++idCounter}`;\n   return prefix ? `${prefix}${id}` /* c8 ignore next */ : id;\n};\n","import Eventbus                        from './Eventbus.js';\n\nexport { default as EventbusProxy }    from './EventbusProxy.js';\nexport { default as EventbusSecure }   from './EventbusSecure.js';\n\nexport default Eventbus;\n\n/**\n * Provides a main eventbus instance.\n *\n * @type {Eventbus}\n */\nexport const eventbus = new Eventbus('mainEventbus');\n\n/**\n * Provides an eventbus instance potentially for use with a plugin system.\n *\n * @type {Eventbus}\n */\nexport const pluginEventbus = new Eventbus('pluginEventbus');\n\n/**\n * Provides an eventbus instance potentially for use for testing.\n *\n * @type {Eventbus}\n */\nexport const testEventbus = new Eventbus('testEventbus');\n"],"names":["EventbusSecure","eventbus","name","TypeError","eventbusSecure","destroy","isDestroyed","this","setEventbus","_classPrivateFieldGet","regex","ReferenceError","entry","keys","trigger","arguments","triggerAsync","triggerDefer","triggerSync","eventSplitter","eventsAPI","iteratee","events","callback","opts","names","i","context","objectKeys","length","test","split","getErrorName","object","Object","beforeMap","map","after","count","beforeWrapper","s_BEFORE","apply","_callback","before","result","args","EventbusProxy","constructor","guarded","Number","isInteger","data","isGuarded","console","warn","Utils","JSON","stringify","off","bind","on","createSecure","initialize","entries","eventCount","callbackCount","s_OFF_API","ctx","s_ON_API","once","RegExp","event","handlers","remaining","j","handler","push","Eventbus","_listeners","_listenId","_listeningTo","createProxy","s_IS_GUARDED","listenTo","obj","s_TRY_CATCH_IS_GUARDED","id","s_UNIQUE_ID","listeningTo","listening","_listening","Listening","error","s_TRY_CATCH_ON","interop","listenToBefore","stopListening","listenToOnce","listeners","ids","Math","max","Array","s_RESULTS_TARGET_API","s_TRIGGER_API","s_TRIGGER_EVENTS","s_TRIGGER_ASYNC_EVENTS","isArray","Promise","all","then","results","allResults","pResult","concat","setTimeout","s_TRIGGER_SYNC_EVENTS","listener","cleanup","incrementCount","value","output","iterateeTarget","resultsType","newArray","objEvents","allEvents","slice","ev","a1","a2","a3","l","call","async","values","filtered","filter","err","idCounter","prefix","pluginEventbus","testEventbus"],"mappings":"saAYe,MAAMA,gHA+BAC,EAAUC,WAEZ,IAATA,GAAmC,iBAATA,QAA2B,IAAIC,UAAW,gCAElEC,EAAiB,IAAIJ,WAC3BI,IAA2BH,KAC3BG,SAAgC,IAATF,EAAkBD,EAASC,KAAOA,GAElD,CACJG,QAAS,WAEDD,EAAeE,gBAEjBF,IAA2B,MAEvBG,YAAaH,oBAAiB,KAIxCI,YAAa,SAASP,EAAUC,WAEhB,IAATA,GAAmC,iBAATA,QAA2B,IAAIC,UAAW,0BAEnEC,EAAeE,mBAGJ,IAATJ,GAAmBO,EAAAL,OAAyBK,EAAAL,KAAyBF,OAEtEE,IAAuBH,EAASC,WAEjB,IAATA,KAENE,IAAuBF,KAG1BE,IAA2BH,KAIjCG,eAAAA,SAWAM,MAECH,KAAKD,kBAAqB,IAAIK,eAAe,wDAE5C,MAAMC,KAASH,UAAeI,KAAKH,SAE/BE,2BAWiB,OAAnBH,wBAUHF,KAAKD,kBAAqB,IAAIK,eAAe,6DAE1CJ,QAWVO,QAAQZ,MAEDK,KAAKD,kBAAqB,IAAIK,eAAe,qEAElCG,WAAWC,WAEnBR,KAYVS,aAAad,MAENK,KAAKD,kBAAqB,IAAIK,eAAe,2DAE1CF,UAAeO,gBAAgBD,WAUzCE,aAAaf,MAENK,KAAKD,kBAAqB,IAAIK,eAAe,qEAElCM,gBAAgBF,WAExBR,KAWVW,YAAYhB,MAELK,KAAKD,kBAAqB,IAAIK,eAAe,2DAE1CF,UAAeS,eAAeH,YCrLpC,MAAMI,EAAgB,MAkBtB,SAASC,EAAUC,EAAUC,EAAQpB,EAAMqB,EAAUC,OAE9CC,EAAPC,EAAI,KACJxB,GAAwB,iBAATA,EACnB,MAEoB,IAAbqB,GAAuB,YAAaC,QAAyB,IAAjBA,EAAKG,UAAsBH,EAAKG,QAAUJ,OACrFE,EAAQG,EAAW1B,GAAOwB,EAAID,EAAMI,OAAQH,IAE9CJ,EAASF,EAAUC,EAAUC,EAAQG,EAAMC,GAAIxB,EAAKuB,EAAMC,IAAKF,QAGhE,GAAItB,GAAQiB,EAAcW,KAAK5B,OAG5BuB,EAAQvB,EAAK6B,MAAMZ,GAAgBO,EAAID,EAAMI,OAAQH,IAEvDJ,EAASD,EAASC,EAAQG,EAAMC,GAAIH,EAAUC,QAMjDF,EAASD,EAASC,EAAQpB,EAAMqB,EAAUC,UAEtCF,EAUH,SAASU,EAAa/B,SAEpBC,EAAOD,EAASC,WACN,KAATA,EAAe,IAAGA,MAAW,GAUhC,MAAM0B,EAAcK,GAEN,OAAXA,GAAqC,iBAAXA,EAAsB,GAAKC,OAAOrB,KAAKoB,GAiBpE,SAASE,EAAUC,EAAKlC,EAAMqB,EAAUC,SAEtCa,EAAQb,EAAKa,MACbC,EAAQd,EAAKc,MAAQ,KAEvBf,EACJ,OACSgB,EAAgBH,EAAIlC,GAAQsC,EAASF,GAAO,kBAExCf,EAASkB,MAAMlC,KAAMQ,cAC5B,KAAQsB,EAAMnC,EAAMqC,MAEvBA,EAAcG,UAAYnB,SAEtBa,EAoBV,MAAMI,EAAW,SAASF,EAAOK,EAAQN,OAElCO,SAEG,YAAYC,WAEVP,EAAQ,IAAKM,EAASD,EAAOF,MAAMlC,KAAMsC,IAE3CP,GAAS,IAEND,GAASA,EAAMI,MAAMlC,KAAMsC,GAC/BR,OAAQ,EACRM,OAAS,GAGLC,oCCpHE,MAAME,EAuBlBC,YAAY9C,0FAEQA,GAoBpB0C,OAAOL,EAAOpC,EAAMqB,EAAUI,EAAkBqB,GAAU,MAEnDzC,KAAKD,kBAAqB,IAAIK,eAAe,uDAC5CsC,OAAOC,UAAUZ,SAAgB,IAAInC,UAAW,mCAE/CgD,EAAO,MACT1C,UAAe2C,UAAUlD,EAAMiD,UAEhCE,QAAQC,KAAM,6BAA4BC,EAAmBhD,wDACPiD,KAAKC,UAAUN,EAAK1B,UACnElB,WAIJe,EAASiC,EAAgBA,EAAiB,GAAIrD,EAAMqB,EAAU,CAAEe,MAAAA,EAAOD,MAAO9B,KAAKmD,IAAIC,KAAKpD,cAE9E,iBAATL,SAAsByB,IAA2CJ,OAAW,GAEhFhB,KAAKqD,GAAGtC,EAAQC,EAAUI,EAASqB,GAW7Ca,aAAa3D,MAENK,KAAKD,kBAAqB,IAAIK,eAAe,0DAE1CX,EAAe8D,aAAWvD,QAAgBL,GAOpDG,UAE0B,OAAnBI,gBAEIiD,oBAGO,YAEE,eAWXhD,MAEFH,KAAKD,kBAAqB,IAAIK,eAAe,uDAE5C,MAAMC,KAASH,UAAesD,QAAQrD,SAElCE,sBAWLL,KAAKD,kBAAqB,IAAIK,eAAe,0DAE1CF,UAAeuD,kCAUlBzD,KAAKD,kBAAqB,IAAIK,eAAe,0DAE1CF,UAAewD,oBAUnBvD,MAECH,KAAKD,kBAAqB,IAAIK,eAAe,uDAE5C,MAAMC,KAASH,UAAeI,KAAKH,SAE/BE,2BAWiB,OAAnBH,wBAUHF,KAAKD,kBAAqB,IAAIK,eAAe,yDAEzC,SAAQF,UAAeP,gCAU3BK,KAAKD,kBAAqB,IAAIK,eAAe,4DAE5CJ,QAEE2B,OAAOrB,OAAKN,SAAcsB,OAFL,8BAYxBtB,KAAKD,kBAAqB,IAAIK,eAAe,yDAE5CJ,eAAuB,MAExB+B,EAAQ,MAEP,MAAMpC,OAAQK,QAAgB+B,GAAS7B,UAAaP,GAAM2B,cAExDS,EAYVc,UAAUlD,EAAMiD,EAAO,OAEhB5C,KAAKD,kBAAqB,IAAIK,eAAe,0DAE1CF,UAAe2C,UAAUlD,EAAMiD,GAgBzCO,IAAIxD,EAAeqB,EAAmBI,MAE/BpB,KAAKD,kBAAqB,IAAIK,eAAe,mEAElC4C,EAAgBW,EAAWzD,WAAgB,GAAIP,EAAMqB,EAAU,CAC3EI,QAASA,EACT1B,WAAUM,WAGNA,KAoBVqD,GAAG1D,EAAMqB,EAAUI,EAAkBqB,GAAU,MAExCzC,KAAKD,kBAAqB,IAAIK,eAAe,yDAE3CwC,EAAO,MACT1C,UAAe2C,UAAUlD,EAAMiD,UAEhCE,QAAQC,KAAM,6BAA4BC,EAAmBhD,oDACXiD,KAAKC,UAAUN,EAAK1B,UAC/DlB,WAIJiB,EAAO,CAAEG,QAAAA,EAASwC,IAAK5D,KAAMyC,QAAAA,mBAEpBO,EAAgBa,EAAU3D,WAAgB,GAAIP,EAAMqB,EAAUC,cAE9DoC,GAAG1D,EAAMqB,EAAUC,EAAK2C,IAAKnB,GAErCzC,KAkBV8D,KAAKnE,EAAMqB,EAAUI,EAAkBqB,GAAU,MAE1CzC,KAAKD,kBAAqB,IAAIK,eAAe,yDAE3CwC,EAAO,MACT1C,UAAe2C,UAAUlD,EAAMiD,UAEhCE,QAAQC,KAAM,6BAA4BC,EAAmBhD,sDACTiD,KAAKC,UAAUN,EAAK1B,UACjElB,WAIJe,EAASiC,EAAgBA,EAAiB,GAAIrD,EAAMqB,EAAU,CAAEe,MAAO,EAAGD,MAAO9B,KAAKmD,IAAIC,KAAKpD,cAEjF,iBAATL,SAAsByB,IAA2CJ,OAAW,GAEhFhB,KAAKqD,GAAGtC,EAAQC,EAAUI,EAASqB,iBAW/BtC,MAEPH,KAAKD,kBAAqB,IAAIK,eAAe,2DACnC,IAAVD,KAAsBA,aAAiB4D,cAAiB,IAAInE,UAAW,gCAEtEI,WAEDG,OAEI,MAAMR,OAAQK,WAEZG,EAAMoB,KAAK5B,OAEP,MAAMqE,KAAS9D,UAAaP,QAExB,CAACA,EAAMqE,EAAMhD,SAAUgD,EAAM5C,QAAS4C,EAAMvB,kBAOtD,MAAM9C,OAAQK,YAEX,MAAMgE,KAAS9D,UAAaP,QAExB,CAACA,EAAMqE,EAAMhD,SAAUgD,EAAM5C,QAAS4C,EAAMvB,oBAanDtC,MAEJH,KAAKD,kBAAqB,IAAIK,eAAe,2DACnC,IAAVD,KAAsBA,aAAiB4D,cAAiB,IAAInE,UAAW,gCAEtEI,WAEDG,MAEI,MAAMR,OAAQK,QAEZG,EAAMoB,KAAK5B,WAENA,YAMP,MAAMA,OAAQK,cAEVL,EAafY,QAAQZ,MAEDK,KAAKD,kBAAqB,IAAIK,eAAe,oEAElCG,WAAWC,WAEnBR,KAYVS,aAAad,MAENK,KAAKD,kBAAqB,IAAIK,eAAe,0DAE1CF,UAAeO,gBAAgBD,WAUzCE,aAAaf,MAENK,KAAKD,kBAAqB,IAAIK,eAAe,oEAElCM,gBAAgBF,WAExBR,KAWVW,YAAYhB,MAELK,KAAKD,kBAAqB,IAAIK,eAAe,0DAE1CF,UAAeS,eAAeH,YAkB3C,MAAMmD,EAAY,CAAC5C,EAAQpB,EAAMqB,EAAUC,SAGnCF,eAECK,EAAUH,EAAKG,QACf1B,EAAWuB,EAAKvB,SAEhBwB,EAAQvB,EAAO,CAACA,GAAQqD,EAAiBjC,OAE1C,IAAII,EAAI,EAAGA,EAAID,EAAMI,OAAQH,IAClC,OAES8C,EAAWlD,EADjBpB,EAAOuB,EAAMC,QAIR8C,cAGCC,EAAY,OACb,IAAIC,EAAI,EAAGA,EAAIF,EAAS3C,OAAQ6C,IACrC,OACSC,EAAUH,EAASE,IAErBnD,GAAYA,IAAaoD,EAAQpD,UAAYA,IAAaoD,EAAQpD,SAASmB,WAC9Ef,GAAWA,IAAYgD,EAAQhD,UAE7B8C,EAAUG,KAAKD,GAKjBF,EAAU5C,OAEXP,EAAOpB,GAAQuE,GAIfxE,EAASyD,IAAIxD,EAAMqB,EAAUI,UACtBL,EAAOpB,WAIboB,GAgBJ8C,EAAW,CAAC9C,EAAQpB,EAAMqB,EAAUC,QAEnCD,EACJ,OACSiD,EAAWlD,EAAOpB,KAAUoB,EAAOpB,GAAQ,IAC3CyB,EAAUH,EAAKG,QAASwC,EAAM3C,EAAK2C,IACnCnB,EAAkC,kBAAjBxB,EAAKwB,SAAwBxB,EAAKwB,QAGzDxB,EAAK2C,IAAMxC,GAAWwC,EAEtBK,EAASI,KAAK,CAAErD,SAAAA,EAAUI,QAAAA,EAASwC,IAAK3C,EAAK2C,IAAKnB,QAAAA,WAG9C1B,mCC/iBK,MAAMuD,EAuBlB9B,YAAY7C,EAAO,qCAfX,4CAiBe,iBAATA,QAA2B,IAAIC,UAAW,mCAExCD,QAQR4E,gBAAa,OAQbC,eAAY,OAQZC,kBAAe,EAoBvBrC,OAAOL,EAAOpC,EAAMqB,EAAUI,EAAkBqB,GAAU,OAElDC,OAAOC,UAAUZ,SAAgB,IAAInC,UAAW,mCAE/CgD,EAAO,MACT5C,KAAK6C,UAAUlD,EAAMiD,UAEtBE,QAAQC,KAAM,6BAA4BC,EAAmBhD,wDACPiD,KAAKC,UAAUN,EAAK1B,UACnElB,WAIJe,EAASiC,EAAgBA,EAAiB,GAAIrD,EAAMqB,EAAU,CAAEe,MAAAA,EAAOD,MAAO9B,KAAKmD,IAAIC,KAAKpD,cAE9E,iBAATL,SAAsByB,IAA2CJ,OAAW,GAEhFhB,KAAKqD,GAAGtC,EAAQC,EAAUI,EAASqB,GAS7CiC,qBAEU,IAAInC,EAAcvC,MAW5BsD,aAAa3D,UAEHF,EAAe8D,WAAWvD,KAAML,YAUjCQ,WAEQ,IAAVA,KAAsBA,aAAiB4D,cAAiB,IAAInE,UAAW,gCAEtEI,WAEDG,OAEI,MAAMR,OAAQK,WAEZG,EAAMoB,KAAK5B,OAEP,MAAMqE,KAAS9D,UAAaP,QAExB,CAACA,EAAMqE,EAAMhD,SAAUgD,EAAM5C,QAAS4C,EAAMvB,kBAOtD,MAAM9C,OAAQK,YAEX,MAAMgE,KAAS9D,UAAaP,QAExB,CAACA,EAAMqE,EAAMhD,SAAUgD,EAAM5C,QAAS4C,EAAMvB,mCAatDzC,QAEE2B,OAAOrB,OAAKN,SAAcsB,OAFL,4BAYvBtB,eAAuB,MAExB+B,EAAQ,MAEP,MAAMpC,OAAQK,QAAgB+B,GAAS7B,UAAaP,GAAM2B,cAExDS,EAYVc,UAAUlD,EAAMiD,EAAO,WAEpBA,EAAK1B,MAAQ,GACb0B,EAAKH,SAAU,EAEAO,EAAgB2B,EAAc/B,EAAMjD,OAAM,EAAQ,CAAEoB,SAAQf,UAE7DyC,cAUXtC,WAEW,IAAVA,KAAsBA,aAAiB4D,cAAiB,IAAInE,UAAW,gCAEtEI,WAEDG,MAEI,MAAMR,OAAQK,QAEZG,EAAMoB,KAAK5B,WAENA,YAMP,MAAMA,OAAQK,cAEVL,sBAYLK,QAmBV4E,SAASC,EAAKlF,EAAMqB,OAEZ6D,SAAc7E,WAEb4C,EAAO,MACTkC,EAAuBD,EAAKlF,EAAMiD,UAEnCE,QAAQC,KAAM,6BAA4BC,EAAmBhD,4EACaiD,KAAKC,UAAUN,EAAK1B,UACvFlB,WAGJ+E,EAAKF,EAAIL,YAAcK,EAAIL,UAAYQ,EAAY,MACnDC,EAAcjF,KAAKyE,eAAiBzE,KAAKyE,aAAe,QAC1DS,EAAYC,EAAaF,EAAYF,GAIpCG,SAEGV,YAAcxE,KAAKwE,UAAYQ,EAAY,MAChDE,EAAYC,EAAaF,EAAYF,GAAM,IAAIK,EAAUpF,KAAM6E,UAI5DQ,EAAQC,EAAeT,EAAKlF,EAAMqB,EAAUhB,SAClDmF,OAAa,EAETE,QAAeA,SAGfH,EAAUK,SAAWL,EAAU7B,GAAG1D,EAAMqB,GAErChB,KAgBVwF,eAAezD,EAAO8C,EAAKlF,EAAMqB,OAEzB0B,OAAOC,UAAUZ,SAAgB,IAAInC,UAAW,mCAG/CmB,EAASiC,EAAgBA,EAAiB,GAAIrD,EAAMqB,EAAU,CACjEe,MAAAA,EACAD,MAAO9B,KAAKyF,cAAcrC,KAAKpD,KAAM6E,YAGjC7E,KAAK4E,SAASC,EAAK9D,GAc7B2E,aAAab,EAAKlF,EAAMqB,SAGfD,EAASiC,EAAgBA,EAAiB,GAAIrD,EAAMqB,EAAU,CACjEe,MAAO,EACPD,MAAO9B,KAAKyF,cAAcrC,KAAKpD,KAAM6E,YAGjC7E,KAAK4E,SAASC,EAAK9D,GAmC7BoC,IAAIxD,EAAMqB,EAAmBI,YAErBpB,kBAEUgD,EAAgBW,IAAW3D,QAAcL,EAAMqB,EAAU,CAAEI,QAAAA,EAASuE,UAAW3F,KAAKuE,cAE5FvE,MAJqBA,KA4C/BqD,GAAG1D,EAAMqB,EAAUI,EAAkBqB,GAAU,SAEtCG,EAAO,UACT5C,KAAK6C,UAAUlD,EAAMiD,IAEtBE,QAAQC,KAAM,6BAA4BC,EAAmBhD,oDACXiD,KAAKC,UAAUN,EAAK1B,UAC/DlB,gBAGKgD,EAAgBa,EAAU3D,WAAgB,GAAIP,EAAMqB,EAAU,CAC1EI,QAAAA,EACAwC,IAAK5D,KACLyC,QAAAA,EACAyC,UAAWC,KAGVA,KAEiBnF,KAAKuE,aAAevE,KAAKuE,WAAa,KAC9CY,EAAWJ,IAAMI,EAG3BA,EAAWI,SAAU,GAGjBvF,MAkBV8D,KAAKnE,EAAMqB,EAAUI,EAAkBqB,GAAU,SAExCG,EAAO,MACT5C,KAAK6C,UAAUlD,EAAMiD,UAEtBE,QAAQC,KAAM,6BAA4BC,EAAmBhD,sDACTiD,KAAKC,UAAUN,EAAK1B,UACjElB,WAIJe,EAASiC,EAAgBA,EAAiB,GAAIrD,EAAMqB,EAAU,CAAEe,MAAO,EAAGD,MAAO9B,KAAKmD,IAAIC,KAAKpD,cAEjF,iBAATL,SAAsByB,IAA2CJ,OAAW,GAEhFhB,KAAKqD,GAAGtC,EAAQC,EAAUI,EAASqB,GAqB7CgD,cAAcZ,EAAKlF,EAAeqB,SAEzBiE,EAAcjF,KAAKyE,iBACpBQ,SAAsBjF,WAErB4F,EAAMf,EAAM,CAACA,EAAIL,WAAaxB,EAAiBiC,OAEhD,IAAI9D,EAAI,EAAGA,EAAIyE,EAAItE,OAAQH,IAChC,OACS+D,EAAYD,EAAYW,EAAIzE,QAG7B+D,QAELA,EAAUL,IAAI1B,IAAIxD,EAAMqB,EAAUhB,MAE9BkF,EAAUK,SAAWL,EAAU/B,IAAIxD,EAAMqB,UAGzChB,KAWVO,QAAQZ,SAEAK,eAAuBA,WAEtBsB,EAASuE,KAAKC,IAAI,EAAGtF,UAAUc,OAAS,GACxCgB,EAAO,IAAIyD,MAAMzE,OAElB,IAAIH,EAAI,EAAGA,EAAIG,EAAQH,IAAOmB,EAAKnB,GAAKX,UAAUW,EAAI,UAE3D6E,EAAqBC,EAAeC,IAAkBlG,QAAcL,OAAM,EAAQ2C,GAE3EtC,wBAYSL,SAEXK,qBAECsB,EAASuE,KAAKC,IAAI,EAAGtF,UAAUc,OAAS,GACxCgB,EAAO,IAAIyD,MAAMzE,OAClB,IAAIH,EAAI,EAAGA,EAAIG,EAAQH,IAAOmB,EAAKnB,GAAKX,UAAUW,EAAI,SAErDkB,EAAS2D,EAAqBC,EAAeE,IAAwBnG,QAAcL,OAAM,EAAQ2C,eAGxF,IAAXD,EAGC0D,MAAMK,QAAQ/D,GAIZgE,QAAQC,IAAIjE,GAAQkE,MAAMC,QAE1BC,EAAa,OAEZ,MAAMC,KAAWF,EAEfT,MAAMK,QAAQM,GAEfD,EAAaA,EAAWE,OAAOD,QAEb,IAAZA,GAEND,EAAWpC,KAAKqC,UAIfD,EAAWnF,OAAS,EAAImF,EAAmC,IAAtBA,EAAWnF,OAAemF,EAAW,QAAK,KApBpDpE,SA+BxC3B,aAAaf,UAEViH,YAAW,UAAarG,WAAWC,aAAe,GAE3CR,KAWVW,YAAYhB,SAEJK,qBAGCsB,EAASuE,KAAKC,IAAI,EAAGtF,UAAUc,OAAS,GACxCgB,EAAO,IAAIyD,MAAMzE,OAClB,IAAIH,EAAI,EAAGA,EAAIG,EAAQH,IAAOmB,EAAKnB,GAAKX,UAAUW,EAHzC,UAKP6E,EAAqBC,EAAeY,IAAuB7G,QAAcL,OAAM,EAAQ2C,IAWpG,IAAI6C,0FAKJ,MAAMC,EAkCH5C,YAAYsE,EAAUjC,oOAFb,aAIKiC,EAAStC,oBACHsC,YACLjC,aACI,GAInBkC,iBAEU7G,UAAeuE,aAAavE,UAAUsE,aACxCxE,gBAAwBE,UAAUqE,aAAWvE,2BAGnCA,+BAEKA,2BAEJA,QAEnBgH,wCAaA3D,GAAG1D,EAAMqB,EAAUI,mBAED4B,EAAgBa,EAAU3D,WAAgB,GAAIP,EAAMqB,EACnE,CACGI,QAAAA,EACAwC,IAAK5D,KACLkF,UAAWlF,QAGPA,KAWVmD,IAAIxD,EAAMqB,OAEH+F,IAEA/G,kBAEcgD,EAAgBW,IAAW3D,QAAcL,EAAMqB,EAAU,CACrEI,aAAS,EACTuE,eAAW,KAEdoB,KAAW/G,iCAKX+G,EAA0B,IAAhB7G,WAGT6G,QAAgBA,sBAQXE,MAGY,kBAAVA,QAA6B,IAAIrH,UAAW,qCACvCqH,IAkBtB,MAAMtC,EAAe,CAACuC,EAAQvH,EAAMqB,EAAUC,WAErCF,EAASE,EAAKF,UAEhBA,EACJ,OACSkD,EAAWlD,EAAOpB,MAEpBoG,MAAMK,QAAQnC,OAEV,MAAMG,KAAWH,KAEfG,EAAQ3B,eAERyE,EAAOhG,MAAMmD,KAAK1E,GAClBuH,EAAOzE,SAAU,EACVyE,SAMbA,GAgBJvD,EAAY,CAAC5C,EAAQpB,EAAMqB,EAAUC,SAGnCF,eAECK,EAAUH,EAAKG,QAASuE,EAAY1E,EAAK0E,cACpCzE,EAAPC,EAAI,KAGHxB,GAASyB,GAAYJ,OAS1BE,EAAQvB,EAAO,CAACA,GAAQqD,EAAiBjC,GAElCI,EAAID,EAAMI,OAAQH,IACzB,OAES8C,EAAWlD,EADjBpB,EAAOuB,EAAMC,QAIR8C,cAGCC,EAAY,OACb,IAAIC,EAAI,EAAGA,EAAIF,EAAS3C,OAAQ6C,IACrC,OACSC,EAAUH,EAASE,MACrBnD,GAAYA,IAAaoD,EAAQpD,UAAYA,IAAaoD,EAAQpD,SAASmB,WAC9Ef,GAAWA,IAAYgD,EAAQhD,QAE7B8C,EAAUG,KAAKD,OAGlB,OACSc,EAAYd,EAAQc,UACtBA,GAAaA,EAAU/B,IAAIxD,EAAMqB,IAKvCkD,EAAU5C,OAEXP,EAAOpB,GAAQuE,SAIRnD,EAAOpB,UAIboB,MA7CCG,EAAQ8B,EAAiB2C,GAAYxE,EAAID,EAAMI,OAAQH,IAEzDwE,EAAUzE,EAAMC,IAAI4F,WA2DvBlD,EAAW,CAAC9C,EAAQpB,EAAMqB,EAAUC,QAEnCD,EACJ,OACSiD,EAAWlD,EAAOpB,KAAUoB,EAAOpB,GAAQ,IAC3CyB,EAAUH,EAAKG,QAASwC,EAAM3C,EAAK2C,IAAKsB,EAAYjE,EAAKiE,UACzDzC,EAAkC,kBAAjBxB,EAAKwB,SAAwBxB,EAAKwB,QAErDyC,GAAaA,EAAU8B,iBAE3B/C,EAASI,KAAK,CAAErD,SAAAA,EAAUI,QAAAA,EAASwC,IAAKxC,GAAWwC,EAAKnB,QAAAA,EAASyC,UAAAA,WAE7DnE,GAqBJiF,EAAuB,CAAClF,EAAUqG,EAAgBpG,EAAQpB,EAAMqB,EAAUC,SAEzEuF,EACOtF,EAAPC,EAAI,KAIJxB,GAAQqD,EAAoBzB,KAAK5B,OAG7BuB,EAAQvB,EAAK6B,MAAMwB,GAAsB7B,EAAID,EAAMI,OAAQH,IAChE,OACSkB,EAASvB,EAASqG,EAAgBpG,EAAQG,EAAMC,GAAIH,EAAUC,GAG9DmG,EAAcrB,MAAMK,QAAQI,GAAW,OAAgB,IAAZA,EAAqB,EAAI,KAGtET,MAAMK,QAAQ/D,UAEP+E,QAEA,EAEFZ,EAAUnE,aAER,EAEFmE,EAAU,CAACA,GAASG,OAAOtE,cAEzB,EAEFmE,EAAUA,EAAQG,OAAOtE,QAI7B,QAAe,IAAXA,SAEE+E,QAEA,EAEFZ,EAAUnE,aAER,SAEIgF,EAAW,CAACb,GAClBa,EAAShD,KAAKhC,GACdmE,EAAUa,aAGR,EAEFb,EAAQnC,KAAKhC,SASzBmE,EAAU1F,EAASqG,EAAgBpG,EAAQpB,EAAMqB,EAAUC,UAGvDuF,GAkBJP,EAAgB,CAACkB,EAAgBG,EAAW3H,EAAMqB,EAAUsB,SAE3DD,KAEAiF,EACJ,OACSvG,EAASuG,EAAU3H,OACrB4H,EAAYD,EAAUhB,IACtBvF,GAAUwG,IAAaA,EAAYA,EAAUC,SAC7CzG,IAAUsB,EAAS8E,EAAepG,EAAQuB,IAC1CiF,IAAalF,EAAS8E,EAAeI,EAAW,CAAC5H,GAAMgH,OAAOrE,YAG9DD,GAWJ6D,EAAmB,CAACnF,EAAQuB,SAE3BmF,EAAItG,GAAK,QACPuG,EAAKpF,EAAK,GAAIqF,EAAKrF,EAAK,GAAIsF,EAAKtF,EAAK,GAAIuF,EAAI9G,EAAOO,cAEnDgB,EAAKhB,aAEL,SACOH,EAAI0G,IAAMJ,EAAK1G,EAAOI,IAAIH,SAAS8G,KAAKL,EAAG7D,iBAElD,SACOzC,EAAI0G,IAAMJ,EAAK1G,EAAOI,IAAIH,SAAS8G,KAAKL,EAAG7D,IAAK8D,eAEvD,SACOvG,EAAI0G,IAAMJ,EAAK1G,EAAOI,IAAIH,SAAS8G,KAAKL,EAAG7D,IAAK8D,EAAIC,eAE3D,SACOxG,EAAI0G,IAAMJ,EAAK1G,EAAOI,IAAIH,SAAS8G,KAAKL,EAAG7D,IAAK8D,EAAIC,EAAIC,yBAGxDzG,EAAI0G,IAAMJ,EAAK1G,EAAOI,IAAIH,SAASkB,MAAMuF,EAAG7D,IAAKtB,YAkB7D6D,EAAyB4B,MAAOhH,EAAQuB,SAEvCmF,EAAItG,GAAK,QACPuG,EAAKpF,EAAK,GAAIqF,EAAKrF,EAAK,GAAIsF,EAAKtF,EAAK,GAAIuF,EAAI9G,EAAOO,OAErDkF,EAAU,UAERlE,EAAKhB,aAEL,SACOH,EAAI0G,GACb,OACSxF,GAAUoF,EAAK1G,EAAOI,IAAIH,SAAS8G,KAAKL,EAAG7D,UAGlC,IAAXvB,GAAqBmE,EAAQnC,KAAKhC,cAIvC,SACOlB,EAAI0G,GACb,OACSxF,GAAUoF,EAAK1G,EAAOI,IAAIH,SAAS8G,KAAKL,EAAG7D,IAAK8D,QAGvC,IAAXrF,GAAqBmE,EAAQnC,KAAKhC,cAIvC,SACOlB,EAAI0G,GACb,OACSxF,GAAUoF,EAAK1G,EAAOI,IAAIH,SAAS8G,KAAKL,EAAG7D,IAAK8D,EAAIC,QAG3C,IAAXtF,GAAqBmE,EAAQnC,KAAKhC,cAIvC,SACOlB,EAAI0G,GACb,OACSxF,GAAUoF,EAAK1G,EAAOI,IAAIH,SAAS8G,KAAKL,EAAG7D,IAAK8D,EAAIC,EAAIC,QAG/C,IAAXvF,GAAqBmE,EAAQnC,KAAKhC,wBAKhClB,EAAI0G,GACb,OACSxF,GAAUoF,EAAK1G,EAAOI,IAAIH,SAASkB,MAAMuF,EAAG7D,IAAKtB,QAGxC,IAAXD,GAAqBmE,EAAQnC,KAAKhC,WAMxCmE,EAAQlF,OAAS,EAAI+E,QAAQC,IAAIE,GAASD,MAAMyB,UAE9CC,EAAWD,EAAOE,QAAQ7H,QAAoB,IAAVA,WAClC4H,EAAS3G,aAET,cACA,SAAU2G,EAAS,kBACRA,MAEE,IAAnBzB,EAAQlF,OAAekF,EAAQ,QAAK,GActCK,EAAwB,CAAC9F,EAAQuB,SAEhCmF,EAAItG,GAAK,QACPuG,EAAKpF,EAAK,GAAIqF,EAAKrF,EAAK,GAAIsF,EAAKtF,EAAK,GAAIuF,EAAI9G,EAAOO,OAErDkF,EAAU,UAERlE,EAAKhB,aAEL,SACOH,EAAI0G,GACb,OACSxF,GAAUoF,EAAK1G,EAAOI,IAAIH,SAAS8G,KAAKL,EAAG7D,UAGlC,IAAXvB,GAAqBmE,EAAQnC,KAAKhC,cAGvC,SACOlB,EAAI0G,GACb,OACSxF,GAAUoF,EAAK1G,EAAOI,IAAIH,SAAS8G,KAAKL,EAAG7D,IAAK8D,QAGvC,IAAXrF,GAAqBmE,EAAQnC,KAAKhC,cAGvC,SACOlB,EAAI0G,GACb,OACSxF,GAAUoF,EAAK1G,EAAOI,IAAIH,SAAS8G,KAAKL,EAAG7D,IAAK8D,EAAIC,QAG3C,IAAXtF,GAAqBmE,EAAQnC,KAAKhC,cAGvC,SACOlB,EAAI0G,GACb,OACSxF,GAAUoF,EAAK1G,EAAOI,IAAIH,SAAS8G,KAAKL,EAAG7D,IAAK8D,EAAIC,EAAIC,QAG/C,IAAXvF,GAAqBmE,EAAQnC,KAAKhC,wBAIhClB,EAAI0G,GACb,OACSxF,GAAUoF,EAAK1G,EAAOI,IAAIH,SAASkB,MAAMuF,EAAG7D,IAAKtB,QAGxC,IAAXD,GAAqBmE,EAAQnC,KAAKhC,WAMxCmE,EAAQlF,OAAS,EAAIkF,EAA6B,IAAnBA,EAAQlF,OAAekF,EAAQ,QAAK,GAevE1B,EAAyB,CAACD,EAAKlF,EAAMiD,EAAO,UAE3CH,GAAU,YAILJ,EAASwC,EAAIhC,UAAUlD,EAAMiD,GACb,kBAAXP,IAAwBI,EAAUJ,GAEhD,MAAO8F,GAEJ1F,GAAU,EACVG,EAAK1B,MAAQ,GACb0B,EAAKH,SAAU,SAGXA,GAiBJ6C,EAAiB,CAACT,EAAKlF,EAAMqB,EAAUI,SAIvCyD,EAAIxB,GAAG1D,EAAMqB,EAAUI,GAE1B,MAAO+G,UAEGA,IASb,IAAIC,EAAY,EAShB,MAAMpD,EAAc,CAACqD,EAAS,YAErBtD,EAAM,MAAIqD,SACTC,EAAU,GAAEA,IAAStD,IAA4BA,GClwC9CrF,EAAW,IAAI4E,EAAS,gBAOxBgE,EAAiB,IAAIhE,EAAS,kBAO9BiE,EAAe,IAAIjE,EAAS"}