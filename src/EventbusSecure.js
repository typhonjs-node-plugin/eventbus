/**
 * EventbusSecure provides a secure wrapper around another Eventbus instance.
 *
 * The main use case of EventbusSecure is to provide a secure eventbus window for general public consumption. Only
 * events can be triggered, but not registered / unregistered.
 *
 * You must use the initialize method passing in an existing Eventbus instance as the eventbus reference is private.
 * In order to secure the eventbus from unwanted access there is no way to access the eventbus reference externally from
 * the EventbusSecure instance. The initialize method returns an {@link EventbusSecureObj} object which contains two
 * functions to control the secure eventbus externally; `destroy` and `setEventbus`. Expose to end consumers just the
 * `eventbusSecure` instance.
 */
export default class EventbusSecure
{
   /**
    * Stores the target eventbus.
    *
    * @type {Eventbus}
    * @private
    */
   #eventbus;

   /**
    * Stores an alternate name instead of returning the wrapped Eventbus instance name.
    *
    * @type {string}
    * @private
    */
   #eventbusSecureName

   /**
    * Creates the EventbusSecure instance with an existing instance of Eventbus. An object / EventbusSecureObj is
    * returned with an EventbusSecure reference and two functions for controlling the underlying Eventbus reference.
    *
    * `destroy()` will destroy the underlying Eventbus reference.
    * `setEventbus(<eventbus>)` will set the underlying reference.
    *
    * @param {Eventbus}   eventbus - The target eventbus instance.
    *
    * @param {string}     [name] - If a name is provided this will be used instead of eventbus name.
    *
    * @returns {EventbusSecureObj} The control object which contains an EventbusSecure reference and control functions.
    */
   static initialize(eventbus, name = void 0)
   {
      if (name !== void 0 && typeof name !== 'string') { throw new TypeError(`'name' is not a string`); }

      const eventbusSecure = new EventbusSecure();
      eventbusSecure.#eventbus = eventbus;
      eventbusSecure.#eventbusSecureName = name === void 0 ? eventbus.name : name;

      return {
         destroy: function()
         {
            if (!eventbusSecure.isDestroyed)
            {
               eventbusSecure.#eventbus = null;

               if (this) { this.eventbusSecure = void 0 }
            }
         },

         setEventbus: function(eventbus, name = void 0)
         {
            if (name !== void 0 && typeof name !== 'string') { throw new TypeError(`'name' is not a string`); }

            if (!eventbusSecure.isDestroyed)
            {
               // Adopt the new eventbus name as the current name set matches the wrapped eventbus.
               if (name === void 0 && eventbusSecure.#eventbusSecureName === eventbusSecure.#eventbus.name)
               {
                  eventbusSecure.#eventbusSecureName = eventbus.name;
               }
               else if (name !== void 0)
               {
                  eventbusSecure.#eventbusSecureName = name;
               }

               eventbusSecure.#eventbus = eventbus;
            }
         },

         eventbusSecure
      };
   }

   /**
    * Returns an iterable for the event names / keys of secured eventbus event listeners.
    *
    * @param {RegExp} [regex] - Optional regular expression to filter event names.
    *
    * @yields
    */
   *keys(regex = void 0)
   {
      if (this.isDestroyed) { throw new ReferenceError('This EventbusSecure instance has been destroyed.'); }

      for (const entry of this.#eventbus.keys(regex))
      {
         yield entry;
      }
   }

   /**
    * Returns whether this instance has already been destroyed.
    *
    * @returns {boolean} Is destroyed state.
    */
   get isDestroyed()
   {
      return this.#eventbus === null;
   }

   /**
    * Returns the name associated with this instance.
    *
    * @returns {string|*} The target eventbus name.
    */
   get name()
   {
      if (this.isDestroyed) { throw new ReferenceError('This EventbusSecure instance has been destroyed.'); }

      return this.#eventbusSecureName;
   }

   /**
    * Trigger callbacks for the given event, or space-delimited list of events. Subsequent arguments to trigger will be
    * passed along to the event callbacks.
    *
    * Please see {@link Eventbus#trigger} as this method takes the same arguments.
    *
    * @returns {EventbusSecure} This instance.
    */
   trigger()
   {
      if (this.isDestroyed) { throw new ReferenceError('This EventbusSecure instance has been destroyed.'); }

      this.#eventbus.trigger(...arguments);

      return this;
   }

   /**
    * Provides `trigger` functionality, but collects any returned Promises from invoked targets and returns a
    * single Promise generated by `Promise.resolve` for a single value or `Promise.all` for multiple results. This is
    * a very useful mechanism to invoke asynchronous operations over an eventbus.
    *
    * Please see {@link Eventbus#triggerAsync} as this method takes the same arguments.
    *
    * @returns {Promise<*|*[]>} A Promise to returning any results.
    */
   triggerAsync()
   {
      if (this.isDestroyed) { throw new ReferenceError('This EventbusSecure instance has been destroyed.'); }

      return this.#eventbus.triggerAsync(...arguments);
   }

   /**
    * Defers invoking `trigger`. This is useful for triggering events in the next clock tick.
    *
    * Please see {@link Eventbus#triggerDefer} as this method takes the same arguments.
    *
    * @returns {EventbusSecure} This EventbusProxy.
    */
   triggerDefer()
   {
      if (this.isDestroyed) { throw new ReferenceError('This EventbusSecure instance has been destroyed.'); }

      this.#eventbus.triggerDefer(...arguments);

      return this;
   }

   /**
    * Provides `trigger` functionality, but collects any returned result or results from invoked targets as a single
    * value or in an array and passes it back to the callee in a synchronous manner.
    *
    * Please see {@link Eventbus#triggerSync} as this method takes the same arguments.
    *
    * @returns {*|*[]} An Array of returned results.
    */
   triggerSync()
   {
      if (this.isDestroyed) { throw new ReferenceError('This EventbusSecure instance has been destroyed.'); }

      return this.#eventbus.triggerSync(...arguments);
   }
}
